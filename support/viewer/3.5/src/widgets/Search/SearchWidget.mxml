<?xml version="1.0" encoding="utf-8"?>
<!--
///////////////////////////////////////////////////////////////////////////
// Copyright (c) 2010-2011 Esri. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
///////////////////////////////////////////////////////////////////////////
-->
<viewer:BaseWidget xmlns:fx="http://ns.adobe.com/mxml/2009"
                   xmlns:s="library://ns.adobe.com/flex/spark"
                   xmlns:mx="library://ns.adobe.com/flex/mx"
                   xmlns:Search="widgets.Search.*"
                   xmlns:viewer="com.esri.viewer.*"
                   xmlns:esri="http://www.esri.com/2008/ags"
                   xmlns:components="com.esri.viewer.components.*"
                   x="600" y="300"
                   initialize="basewidget_initializeHandler()"
                   widgetConfigLoaded="basewidget_widgetConfigLoaded()">

    <viewer:states>
        <s:State name="graphicalInput"/>
        <s:State name="textInput"/>
        <s:State name="resultsList"/>
    </viewer:states>

    <viewer:transitions>
        <s:Transition autoReverse="true" toState="*">
            <s:Fade id="fade"/>
        </s:Transition>
    </viewer:transitions>

    <fx:Script>
        <![CDATA[
            import com.esri.ags.FeatureSet;
            import com.esri.ags.Graphic;
            import com.esri.ags.Map;
            import com.esri.ags.clusterers.IClusterer;
            import com.esri.ags.events.DrawEvent;
            import com.esri.ags.events.GeometryServiceEvent;
            import com.esri.ags.events.LayerEvent;
            import com.esri.ags.geometry.Extent;
            import com.esri.ags.geometry.Geometry;
            import com.esri.ags.geometry.MapPoint;
            import com.esri.ags.geometry.Polygon;
            import com.esri.ags.layers.FeatureLayer;
            import com.esri.ags.layers.supportClasses.FeatureCollection;
            import com.esri.ags.layers.supportClasses.LayerDetails;
            import com.esri.ags.portal.PopUpRenderer;
            import com.esri.ags.portal.supportClasses.PopUpInfo;
            import com.esri.ags.portal.supportClasses.PopUpMediaInfo;
            import com.esri.ags.renderers.SimpleRenderer;
            import com.esri.ags.symbols.PictureMarkerSymbol;
            import com.esri.ags.symbols.SimpleFillSymbol;
            import com.esri.ags.symbols.SimpleLineSymbol;
            import com.esri.ags.symbols.SimpleMarkerSymbol;
            import com.esri.ags.symbols.Symbol;
            import com.esri.ags.tasks.GeometryServiceSingleton;
            import com.esri.ags.tasks.supportClasses.Query;
            import com.esri.ags.tools.DrawTool;
            import com.esri.ags.utils.GeometryUtil;
            import com.esri.viewer.AppEvent;
            import com.esri.viewer.utils.ClustererParser;
            import com.esri.viewer.utils.ErrorMessageUtil;
            import com.esri.viewer.utils.LabelUtil;

            import mx.collections.ArrayCollection;
            import mx.collections.ArrayList;
            import mx.core.LayoutDirection;
            import mx.events.FlexEvent;
            import mx.rpc.AsyncResponder;
            import mx.rpc.events.FaultEvent;
            import mx.utils.StringUtil;

            import spark.components.supportClasses.ItemRenderer;

            import widgets.supportClasses.FeatureSetUtil;
            import widgets.supportClasses.ResultAttributes;
            import widgets.supportClasses.ResultItem;

            private const ICON_URL:String = "assets/images/";

            private var configSearchGraphical:Array;
            private var configSearchText:Array;
            private var finishDrawing:Boolean;
            private var graphicalsearchLabel:String;
            private var loadingLabel:String;
            private var nolayerLabel:String;
            private var queryLayer:FeatureLayer;
            private var queryGeom:Geometry;
            private var queryExpr:String;
            private var queryFields:XMLList;
            private var queryTitleField:String;
            private var queryLinkField:String;
            private var queryLinkAlias:String;
            private var resultsLabel:String;
            private var selectionLabel:String;
            private var selectedDrawingIcon:FocusableImage;
            private var textsearchLabel:String;
            private var zoomScale:Number = 50000;

            [Bindable]
            private var clearLabel:String;
            [Bindable]
            private var layerLabel:String;
            [Bindable]
            private var lineLabel:String;
            [Bindable]
            private var freehandLineLabel:String;
            [Bindable]
            private var noResultLabel:String;
            [Bindable]
            private var pointLabel:String;
            [Bindable]
            private var polygonLabel:String;
            [Bindable]
            private var freehandPolygonLabel:String;
            [Bindable]
            private var rectangleLabel:String;
            [Bindable]
            private var circleLabel:String;
            [Bindable]
            private var searchResultAC:ArrayCollection;
            [Bindable]
            private var submitLabel:String;
            [Bindable]
            private var msgVisible:Boolean = false;

            private var drawSymbol:Symbol;
            private var resultMarkerSymbol:Symbol;
            private var resultLineSymbol:Symbol;
            private var resultFillSymbol:Symbol;
            private var shareResults:Boolean;

            private var pointSearchTolerance:Number = 6;

            private var popUpRenderer:PopUpRenderer = new PopUpRenderer();
            private var resultFeatureLayer:FeatureLayer;

            private function basewidget_initializeHandler():void
            {
                if (isPartOfPanel) // if widget is part of "left", "right" or "bottom" panel
                {
                    this.percentWidth = this.percentHeight = 100;
                    wTemplate.percentWidth = wTemplate.percentHeight = 100;
                }
                else
                {
                    wTemplate.width = 430;
                    wTemplate.height = 240;
                }
            }

            private function basewidget_widgetConfigLoaded():void
            {
                if (configXML)
                {
                    geometryService.url = GeometryServiceSingleton.instance.url;
                    geometryService.token = GeometryServiceSingleton.instance.token;
                    geometryService.proxyURL = GeometryServiceSingleton.instance.proxyURL;

                    graphicalsearchLabel = configXML.labels.graphicalsearchlabel || getDefaultString("graphicalTitleBarTooltip");
                    textsearchLabel = configXML.labels.textsearchlabel || getDefaultString("textTitleBarTooltip");
                    resultsLabel = configXML.labels.resultslabel || getDefaultString("resultsLabel");
                    layerLabel = configXML.labels.layerlabel || getDefaultString("layerLabel");
                    nolayerLabel = configXML.labels.nolayerlabel || getDefaultString("nolayerLabel");
                    submitLabel = configXML.labels.submitlabel || getDefaultString("searchSubmitLabel");
                    pointLabel = configXML.labels.pointlabel || getDefaultString("drawPointLabel");
                    lineLabel = configXML.labels.linelabel || getDefaultString("drawLineLabel");
                    freehandLineLabel = configXML.labels.freehandlinelabel || getDefaultString("drawFreehandLineLabel");
                    rectangleLabel = configXML.labels.rectanglelabel || getDefaultString("drawRectangleLabel");
                    circleLabel = configXML.labels.circlelabel || getDefaultString("drawCircleLabel");
                    polygonLabel = configXML.labels.polygonlabel || getDefaultString("drawPolygonLabel");
                    freehandPolygonLabel = configXML.labels.freehandpolygonlabel || getDefaultString("drawFreehandPolygonLabel");

                    clearLabel = configXML.labels.clearlabel || getDefaultString("clearLabel");
                    loadingLabel = configXML.labels.loadinglabel || getDefaultString("loadingLabel");
                    selectionLabel = configXML.labels.selectionlabel || getDefaultString("selectionLabel");
                    noResultLabel = configXML.labels.noresultlabel || getDefaultString("noFeatures");

                    shareResults = configXML.shareresults[0] && configXML.shareresults == "true";

                    configSearchGraphical = [];
                    configSearchText = [];
                    var lyrList:XMLList = configXML..layer;
                    for (var i:int = 0; i < lyrList.length(); i++)
                    {
                        var lyrURL:String = lyrList[i].url;
                        var lyrLabel:String = lyrList[i].name;
                        var lyrGraphicalLabel:String = lyrList[i].graphicalsearchlabel || getDefaultString("graphicalsearchLabel");
                        var lyrTextLabel:String = lyrList[i].textsearchlabel || getDefaultString("textsearchLabel");
                        var lyrExpr:String = lyrList[i].expression;
                        var lyrFields:XMLList = lyrList[i].fields;
                        var lyrTitleField:String = lyrList[i].titlefield;
                        var lyrLinkField:String = lyrList[i].linkfield;
                        var linkAlias:String = lyrList[i].linkfield.@alias[0];
                        var useAMF:String = lyrList[i].useamf;
                        var useProxy:Boolean = lyrList[i].useproxy[0] && lyrList[i].useproxy == "true";

                        const orderByFieldsText:String = lyrList[i].orderbyfields[0];
                        var lyrOrderByFields:Array;
                        if (orderByFieldsText)
                        {
                            lyrOrderByFields = orderByFieldsText.split(',');
                        }

                        var layer:FeatureLayer = new FeatureLayer();
                        layer.addEventListener(LayerEvent.LOAD, searchLayer_loadHandler);
                        layer.addEventListener(LayerEvent.LOAD_ERROR, searchLayer_faultHandler);
                        layer.url = lyrURL;
                        layer.name = buildLayerName(lyrLabel);

                        if (useProxy && configData.proxyUrl)
                        {
                            layer.proxyURL = configData.proxyUrl;
                        }
                        if (useAMF)
                        {
                            layer.useAMF = useAMF == "true";
                        }
                        if (lyrFields && lyrFields[0].@all[0] == "true")
                        {
                            layer.outFields = [ "*" ];
                        }
                        else if (lyrFields)
                        {
                            var fields:XMLList = lyrFields.field;
                            layer.outFields = [];
                            for each (var fieldXML:XML in fields)
                            {
                                if (fieldXML.@name[0])
                                {
                                    layer.outFields.push(fieldXML.@name[0]);
                                }
                            }
                        }

                        var searchLayer:Object =
                            {
                                layer: layer,
                                label: lyrLabel,
                                textlabel: lyrTextLabel,
                                graphicallabel: lyrGraphicalLabel,
                                expr: lyrExpr,
                                fields: lyrFields,
                                orderbyfields: lyrOrderByFields,
                                titlefield: lyrTitleField,
                                linkfield: lyrLinkField,
                                linkalias: linkAlias
                            };
                        configSearchGraphical.push(searchLayer);
                        if (lyrExpr)
                        {
                            configSearchText.push(searchLayer);
                        }
                    }

                    const resultMarkerSymbolURL:String = configXML.symbols.picturemarkersymbol.@url || widgetIcon;
                    const parsedResultMarkerSymbolHeight:Number = parseFloat(configXML.symbols.picturemarkersymbol.@height[0]);
                    const resultMarkerSymbolHeight:Number = isNaN(parsedResultMarkerSymbolHeight) ? 0 : parsedResultMarkerSymbolHeight;
                    const parsedResultMarkerSymbolWidth:Number = parseFloat(configXML.symbols.picturemarkersymbol.@width[0]);
                    const resultMarkerSymbolWidth:Number = isNaN(parsedResultMarkerSymbolWidth) ? 0 : parsedResultMarkerSymbolWidth;
                    const resultMarkerSymbolXOffset:Number = (configXML.symbols.picturemarkersymbol.@xoffset != null) ? configXML.symbols.picturemarkersymbol.@xoffset : 0;
                    const resultMarkerSymbolYOffset:Number = (configXML.symbols.picturemarkersymbol.@yoffset != null) ? configXML.symbols.picturemarkersymbol.@yoffset : 0;
                    resultMarkerSymbol = new PictureMarkerSymbol(resultMarkerSymbolURL, resultMarkerSymbolWidth, resultMarkerSymbolHeight, resultMarkerSymbolXOffset, resultMarkerSymbolYOffset);

                    const resultLineSymbolColor:uint = (configXML.symbols.simplelinesymbol.@color[0] != null) ? configXML.symbols.simplelinesymbol.@color : 0xFF0000;
                    const resultLineSymbolAlpha:Number = (configXML.symbols.simplelinesymbol.@alpha[0] != null) ? configXML.symbols.simplelinesymbol.@alpha : 0.8;
                    const resultLineSymbolWidth:Number = (configXML.symbols.simplelinesymbol.@width[0] != null) ? configXML.symbols.simplelinesymbol.@width : 2;
                    resultLineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, resultLineSymbolColor, resultLineSymbolAlpha, resultLineSymbolWidth);

                    const resultFillSymbolColor:uint = (configXML.symbols.simplefillsymbol.@color[0] != null) ? configXML.symbols.simplefillsymbol.@color : 0xFF0000;
                    const resultFillSymbolAlpha:Number = (configXML.symbols.simplefillsymbol.@alpha[0] != null) ? configXML.symbols.simplefillsymbol.@alpha : 0.5;
                    const resultFillSymbolOutlineColor:uint = (configXML.symbols.simplefillsymbol.outline.@color[0] != null) ? configXML.symbols.simplefillsymbol.outline.@color : 0xFF0000;
                    const resultFillSymbolOutlineAlpha:Number = (configXML.symbols.simplefillsymbol.outline.@alpha[0] != null) ? configXML.symbols.simplefillsymbol.outline.@alpha : 0.8;
                    const resultFillSymbolOutlineWidth:Number = (configXML.symbols.simplefillsymbol.outline.@width[0] != null) ? configXML.symbols.simplefillsymbol.outline.@width : 2;
                    resultFillSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, resultFillSymbolColor, resultFillSymbolAlpha, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, resultFillSymbolOutlineColor, resultFillSymbolOutlineAlpha, resultFillSymbolOutlineWidth));

                    resultFeatureLayer = new FeatureLayer();
                    resultFeatureLayer.visible = false;
                    resultFeatureLayer.isEditable = false;

                    var clustererParser:ClustererParser = new ClustererParser();
                    var clusterer:IClusterer = clustererParser.parseClusterer(configXML.clustering[0]);
                    if (clusterer)
                    {
                        resultFeatureLayer.clusterer = clusterer;
                    }

                    resultFeatureLayer.addEventListener(FlexEvent.HIDE, resultFeatureLayer_hideHandler);

                    var userTolerance:Number = configXML.tolerance;
                    if (userTolerance > 0)
                    {
                        pointSearchTolerance = userTolerance;
                    }

                    if (Number(configXML.zoomscale) > 0)
                    {
                        zoomScale = Number(configXML.zoomscale);
                    }
                }
                wTemplate.addTitlebarButton(ICON_URL + "i_searchgraphical.png", graphicalsearchLabel, showStateGraphicalSearch);
                if (configSearchText.length)
                {
                    wTemplate.addTitlebarButton(ICON_URL + "i_searchtext.png", textsearchLabel, showStateTextSearch);
                }
                wTemplate.addTitlebarButton(ICON_URL + "i_table.png", resultsLabel, showStateResults);

                setInitialView(configXML.initialview[0]);
                fade.targets = [ graphicalInput, textInput, resultsList ];
                wTemplate.visible = true;

                setupTextSearch();
                setupGraphicalSearch();
                AppEvent.addListener(AppEvent.DATA_PUBLISH, sharedDataUpdated);
            }

            private function buildLayerName(name:String):String
            {
                var widgetName:String = configXML.layername || widgetTitle;
                name = name ? name : widgetName;

                if (widgetName == name)
                {
                    return shareResults ? widgetName : "hiddenLayer_" + widgetName;
                }

                var layerNameTemplate:String =
                    (layoutDirection == LayoutDirection.LTR) ? "{0} - {1}" : "{1} - {0}";

                layerNameTemplate =
                    shareResults ? layerNameTemplate : "hiddenLayer_" + layerNameTemplate;

                return StringUtil.substitute(layerNameTemplate, widgetName, name);
            }

            private function searchLayer_loadHandler(event:LayerEvent):void
            {
                var layer:FeatureLayer = event.layer as FeatureLayer;
                layer.removeEventListener(LayerEvent.LOAD, searchLayer_loadHandler);
                layer.removeEventListener(LayerEvent.LOAD_ERROR, searchLayer_faultHandler);

                layer.layerDetails.minScale = 0; // removing scale dependency
                layer.layerDetails.maxScale = 0;
            }

            private function searchLayer_faultHandler(event:LayerEvent):void
            {
                var layer:FeatureLayer = event.currentTarget as FeatureLayer;

                layer.removeEventListener(LayerEvent.LOAD, searchLayer_loadHandler);
                layer.removeEventListener(LayerEvent.LOAD_ERROR, searchLayer_faultHandler);

                showLoadErrorMessage(event);
            }

            private function showLoadErrorMessage(event:LayerEvent):void
            {
                var errorMessage:String = getDefaultString("layerFailedToLoad",
                                                           event.layer.name,
                                                           ErrorMessageUtil.makeHTMLSafe(ErrorMessageUtil.buildFaultMessage(event.fault)));

                showError(errorMessage);
            }

            private function setInitialView(view:String):void
            {
                if (view == "graphical")
                {
                    showStateGraphicalSearch();
                }
                else if (view == "text")
                {
                    showStateTextSearch();
                }
            }

            private function setupTextSearch():void
            {
                if (configSearchText.length)
                {
                    cboLayerText.dataProvider = new ArrayList(configSearchText);
                    txtLabelText.text = configSearchText[0].textlabel;
                    if (configSearchText.length == 1)
                    {
                        boxText.visible = false;
                        boxText.includeInLayout = false;
                    }
                    else
                    {
                        cboLayerText.typicalItem = LabelUtil.findLongestLabelItem(configSearchText, "label");
                    }
                }
                else
                {
                    boxText.visible = false;
                    txtLabelText.text = nolayerLabel;
                }
            }

            private function setupGraphicalSearch():void
            {
                if (configSearchGraphical.length)
                {
                    cboLayerGraphical.dataProvider = new ArrayList(configSearchGraphical);
                    txtLabelGraphical.text = configSearchGraphical[0].graphicallabel;
                    if (configSearchGraphical.length == 1)
                    {
                        boxGraphical.visible = false;
                        boxGraphical.includeInLayout = false;
                    }
                    else
                    {
                        cboLayerGraphical.typicalItem = LabelUtil.findLongestLabelItem(configSearchGraphical, "label");
                    }
                }
                else
                {
                    boxGraphical.visible = false;
                    imageGroup.visible = false;
                    clearGroup.visible = false;
                    txtLabelGraphical.text = nolayerLabel;
                }
            }

            private function resultFeatureLayer_hideHandler(event:FlexEvent):void
            {
                hideInfoWindow();
            }

            private function searchLayerChangedText():void
            {
                txtLabelText.text = cboLayerText.selectedItem.textlabel;
            }

            private function searchLayerChangedGraphical():void
            {
                txtLabelGraphical.text = cboLayerGraphical.selectedItem.graphicallabel;
            }

            private function activateDrawTool(event:MouseEvent):void
            {
                addSharedData("Deactivate_DrawTool", null); // to be able to deactivate drawTool on other widgets

                // apply glow
                selectedDrawingIcon = FocusableImage(event.currentTarget);
                clearSelectionFilter();
                selectedDrawingIcon.filters = [ glowFilter ];

                finishDrawing = false;

                var status:String;
                var value:String = selectedDrawingIcon.name;
                switch (value)
                {
                    case DrawTool.MAPPOINT:
                    {
                        status = pointLabel;
                        drawSymbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE, 15, 0x3FAFDC, 1);
                        break;
                    }
                    case DrawTool.POLYLINE:
                    {
                        status = lineLabel;
                        drawSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, 0x3FAFDC, 1, 1);
                        break;
                    }
                    case DrawTool.EXTENT:
                    {
                        status = rectangleLabel;
                        drawSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, 0x3FAFDC, 0.5, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, 0x3FAFDC, 1, 1));
                        break;
                    }
                    case DrawTool.POLYGON:
                    {
                        status = polygonLabel;
                        drawSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, 0x3FAFDC, 0.5, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, 0x3FAFDC, 1, 1));
                        break;
                    }
                }
                setMapAction(value, status, drawSymbol, searchDrawEnd);
            }

            private function searchDrawEnd(event:DrawEvent):void
            {
                // deactivate the draw tool
                finishDrawing = true;

                selectedDrawingIcon = null;
                clearSelectionFilter();

                event.target.deactivate();
                var geom:Geometry = event.graphic.geometry;

                if (geom is Polygon && GeometryUtil.polygonSelfIntersecting(geom as Polygon))
                {
                    geometryService.simplify([ geom ]);
                }
                else
                {
                    //to improve search results
                    if (geom.type == Geometry.MAPPOINT)
                    {
                        geom = createExtentAroundMapPoint(geom as MapPoint, pointSearchTolerance);
                    }

                    queryFeaturesGraphical(geom);
                }
            }

            private function createExtentAroundMapPoint(centerPoint:MapPoint, tolerance:Number):Extent
            {
                var screenPoint:Point = map.toScreen(centerPoint as MapPoint);

                var upperLeftScreenPoint:Point = new Point(screenPoint.x - tolerance, screenPoint.y - tolerance);
                var lowerRightScreenPoint:Point = new Point(screenPoint.x + tolerance, screenPoint.y + tolerance);

                var upperLeftMapPoint:MapPoint = map.toMap(upperLeftScreenPoint);
                var lowerRightMapPoint:MapPoint = map.toMap(lowerRightScreenPoint);

                return new Extent(upperLeftMapPoint.x, upperLeftMapPoint.y, lowerRightMapPoint.x, lowerRightMapPoint.y, map.spatialReference);
            }

            private function queryFeaturesText():void
            {
                hideInfoWindow();

                var searchLayer:Object = cboLayerText.selectedItem;

                queryLayer = searchLayer.layer;

                if (queryLayer && !queryLayer.loaded)
                {
                    queryLayer.addEventListener(LayerEvent.LOAD, queryLayer_loadHandler);
                    queryLayer.addEventListener(LayerEvent.LOAD_ERROR, queryLayer_loadErrorHandler);

                    function queryLayer_loadHandler(event:LayerEvent):void
                    {
                        queryLayer.removeEventListener(LayerEvent.LOAD, queryLayer_loadHandler);
                        queryLayer.removeEventListener(LayerEvent.LOAD_ERROR, queryLayer_loadErrorHandler);

                        queryFeaturesText();
                    }

                    function queryLayer_loadErrorHandler(event:LayerEvent):void
                    {
                        queryLayer.removeEventListener(LayerEvent.LOAD, queryLayer_loadHandler);
                        queryLayer.removeEventListener(LayerEvent.LOAD_ERROR, queryLayer_loadErrorHandler);

                        showLoadErrorMessage(event);
                    }

                    return;
                }

                queryExpr = searchLayer.expr;
                queryFields = searchLayer.fields;
                queryTitleField = searchLayer.titlefield;
                queryLinkField = searchLayer.linkfield;
                queryLinkAlias = searchLayer.linkalias;

                if (queryLayer && txtSearch.text)
                {
                    var query:Query = new Query();
                    var expr:String = queryExpr.replace(/\[value\]/g, txtSearch.text);

                    query.where = expr;
                    query.outSpatialReference = map.spatialReference;

                    const supportsServerSideSorting:Boolean = queryLayer.layerDetails
                        && queryLayer.layerDetails.version >= 10.1
                        && queryLayer.layerDetails.supportsAdvancedQueries;
                    const orderByFields:Array = searchLayer.orderbyfields;
                    if (supportsServerSideSorting && orderByFields)
                    {
                        query.orderByFields = orderByFields;
                    }

                    var queryOptions:Object =
                        {
                            supportsServerSideSorting: supportsServerSideSorting,
                            orderByFields: orderByFields,
                            queryFields: queryFields
                        };

                    queryLayer.queryFeatures(
                        query, new AsyncResponder(queryFeatures_resultHandler,
                                                  queryFeatures_faultHandler,
                                                  queryOptions));

                    showMessage(loadingLabel, true);
                    showStateResults();
                }
            }

            private function queryFeatures_resultHandler(featureSet:FeatureSet, queryOptions:Object):void
            {
                try
                {
                    if (!queryOptions.supportsServerSideSorting && queryOptions.orderByFields)
                    {
                        FeatureSetUtil.sortFeaturesByFieldName(featureSet, queryOptions.orderByFields);
                    }

                    if (searchResultAC)
                    {
                        searchResultAC.removeAll();
                    }
                    searchResultAC = createSearchResults(featureSet, queryOptions.queryFields);

                    addSharedData(widgetTitle, searchResultAC);
                    if (featureSet.features.length < 1)
                    {
                        showMessage(noResultLabel, false);
                    }
                    else
                    {
                        showMessage(selectionLabel + " " + featureSet.features.length, false);
                    }
                }
                catch (error:Error)
                {
                    showMessage(error.message, false);
                }

                if (!resultFeatureLayer.map)
                {
                    map.addLayer(resultFeatureLayer);
                }
            }

            private function queryFeatures_faultHandler(info:Object, queryOptions:Object):void
            {
                showMessage(info.toString(), false);
            }

            private function queryFeaturesGraphical(geom:Geometry):void
            {
                hideInfoWindow();

                var searchLayer:Object = cboLayerGraphical.selectedItem;

                queryLayer = searchLayer.layer;

                if (queryLayer && !queryLayer.loaded)
                {
                    queryLayer.addEventListener(LayerEvent.LOAD, queryLayer_loadHandler);
                    queryLayer.addEventListener(LayerEvent.LOAD_ERROR, queryLayer_faultHandler);

                    function queryLayer_loadHandler(event:LayerEvent):void
                    {
                        queryLayer.removeEventListener(LayerEvent.LOAD, queryLayer_loadHandler);
                        queryLayer.removeEventListener(LayerEvent.LOAD_ERROR, queryLayer_faultHandler);

                        queryFeaturesGraphical(geom);
                    }

                    function queryLayer_faultHandler(event:LayerEvent):void
                    {
                        queryLayer.removeEventListener(LayerEvent.LOAD, queryLayer_loadHandler);
                        queryLayer.removeEventListener(LayerEvent.LOAD_ERROR, queryLayer_faultHandler);

                        showLoadErrorMessage(event);
                    }

                    return;
                }

                queryGeom = geom;
                queryFields = searchLayer.fields;
                queryTitleField = searchLayer.titlefield;
                queryLinkField = searchLayer.linkfield;
                queryLinkAlias = searchLayer.linkalias;

                if (queryLayer)
                {
                    var query:Query = new Query();
                    query.geometry = queryGeom;
                    query.spatialRelationship = Query.SPATIAL_REL_INTERSECTS;
                    query.outSpatialReference = map.spatialReference;

                    const supportsServerSideSorting:Boolean = queryLayer.layerDetails
                        && queryLayer.layerDetails.version >= 10.1
                        && queryLayer.layerDetails.supportsAdvancedQueries;
                    const orderByFields:Array = searchLayer.orderbyfields;
                    if (supportsServerSideSorting && orderByFields)
                    {
                        query.orderByFields = orderByFields;
                    }

                    var queryOptions:Object =
                        {
                            supportsServerSideSorting: supportsServerSideSorting,
                            orderByFields: orderByFields,
                            queryFields: queryFields
                        };

                    queryLayer.queryFeatures(
                        query, new AsyncResponder(queryFeatures_resultHandler,
                                                  queryFeatures_faultHandler,
                                                  queryOptions));

                    showMessage(loadingLabel, true);
                    showStateResults();
                }
            }

            private function createSearchResults(featureSet:FeatureSet, queryFields:XMLList):ArrayCollection
            {
                var result:ArrayCollection = new ArrayCollection();

                var layerDetails:LayerDetails = queryLayer.layerDetails;
                if (!queryTitleField)
                {
                    queryTitleField = featureSet.displayFieldName;
                }

                var defaultSymbol:Symbol = getMatchingDefaultSymbol(featureSet.geometryType);
                var resultAttributes:ResultAttributes;
                var infoWindowRenderer:ClassFactory;

                for each (var graphic:Graphic in featureSet.features)
                {
                    graphic.symbol = defaultSymbol;

                    resultAttributes =
                        ResultAttributes.toResultAttributes(queryFields, graphic, featureSet,
                                                            queryLayer, layerDetails, widgetTitle,
                                                            queryTitleField, queryLinkField, queryLinkAlias);

                    result.addItem(new ResultItem(graphic, resultAttributes));

                    infoWindowRenderer = new ClassFactory(PopUpRenderer);
                    infoWindowRenderer.properties = { popUpInfo: configurePopUpInfo(resultAttributes)};
                    graphic.infoWindowRenderer = infoWindowRenderer;
                }

                resultFeatureLayer.outFields = queryLayer.outFields;
                resultFeatureLayer.visible = true;
                resultFeatureLayer.featureCollection = new FeatureCollection(featureSet, layerDetails);
                resultFeatureLayer.name = queryLayer.name;
                resultFeatureLayer.renderer = new SimpleRenderer(defaultSymbol);

                return result;
            }

            private function getMatchingDefaultSymbol(geometryType:String):Symbol
            {
                var defaultSymbol:Symbol;

                switch (geometryType)
                {
                    case Geometry.MAPPOINT:
                    {
                        defaultSymbol = resultMarkerSymbol;
                        break;
                    }
                    case Geometry.POLYLINE:
                    {
                        defaultSymbol = resultLineSymbol;
                        break;
                    }
                    case Geometry.POLYGON:
                    {
                        defaultSymbol = resultFillSymbol;
                        break;
                    }
                }

                return defaultSymbol;
            }

            private function configurePopUpInfo(resultAttributes:ResultAttributes):PopUpInfo
            {
                var popUpInfo:PopUpInfo = new PopUpInfo;

                popUpInfo.title = resultAttributes.title;
                popUpInfo.description = resultAttributes.content;

                var link:String = resultAttributes.link;
                var linkAlias:String = resultAttributes.linkAlias
                if (link)
                {
                    var pos:Number = link.length - 4;
                    var sfx:String = link.substr(pos, 4).toLowerCase();
                    var isImageLink:Boolean = (sfx == ".jpg") || (sfx == ".png") || (sfx == ".gif");

                    if (isImageLink)
                    {
                        var popUpMediaInfo:PopUpMediaInfo = new PopUpMediaInfo;
                        popUpMediaInfo.type = PopUpMediaInfo.IMAGE;
                        popUpMediaInfo.imageLinkURL = link;
                        popUpMediaInfo.imageSourceURL = link;
                        popUpInfo.popUpMediaInfos = [ popUpMediaInfo ];
                    }
                    else
                    {
                        var linkText:String = linkAlias ? linkAlias : link;
                        popUpInfo.description += "<br/><a href='" + link + "'>" + linkText + "</a>";
                    }
                }

                return popUpInfo;
            }

            private function clear():void
            {
                hideInfoWindow();
                if (resultFeatureLayer)
                {
                    resultFeatureLayer.featureCollection = new FeatureCollection(new FeatureSet(), resultFeatureLayer.layerDetails); // empty featureset to clear
                }

                clearMessage();
                txtSearch.text = "";
                if (searchResultAC)
                {
                    searchResultAC.removeAll();
                }
            }

            private var hitimer:uint;

            private function mouseOverSearchResult(event:Event):void
            {
                if (resultFeatureLayer.visible)
                {
                    clearTimeout(hitimer);
                    var searchResult:ResultItem = ItemRenderer(event.target).data as ResultItem;
                    var mapExtentContainsSearchResult:Boolean = map.extent.containsXY(searchResult.center.x, searchResult.center.y);

                    if (mapExtentContainsSearchResult)
                    {
                        hitimer = setTimeout(showHighlight, 300, [ searchResult ]);
                    }
                    else
                    {
                        hideInfoWindow();
                    }
                }
            }

            private function mouseOutSearchResult(event:Event):void
            {
                clearTimeout(hitimer);
            }

            private function clickSearchResult(event:Event):void
            {
                if (resultFeatureLayer.visible)
                {
                    var searchResult:ResultItem = ItemRenderer(event.target).data as ResultItem;
                    if (searchResult.geometry)
                    {
                        if (searchResult.geometry.type == Geometry.MAPPOINT)
                        {
                            if (map.scale > zoomScale)
                            {
                                map.scale = zoomScale;
                            }
                        }

                        map.zoomTo(searchResult.geometry);
                    }
                    clearTimeout(hitimer);
                    hitimer = setTimeout(showHighlight, 300, [ searchResult ]);
                }
            }

            private function showHighlight(params:Array):void
            {
                var searchResult:ResultItem = params[0];
                var showHighlightPoint:MapPoint = searchResult.center as MapPoint;
                var linkAlias:String = searchResult.attributes.linkAlias;

                popUpRenderer.popUpInfo = configurePopUpInfo(searchResult.attributes);
                popUpRenderer.graphic = searchResult.graphic;

                map.infoWindow.content = popUpRenderer;
                map.infoWindow.contentOwner = popUpRenderer.graphic;
                map.infoWindow.show(showHighlightPoint);
            }

            private function showMessage(msg:String, swfVisible:Boolean):void
            {
                txtMessage.text = msg;
                swfMessage.visible = swfVisible;
                msgVisible = true;
            }

            private function clearMessage():void
            {
                msgVisible = false;
            }

            private function widgetClosedHandler(event:Event):void
            {
                if (shareResults)
                {
                    map.removeLayer(resultFeatureLayer);
                }
                else
                {
                    resultFeatureLayer.visible = false;
                }
                hideInfoWindow();
                setMapNavigation(null, null);

                finishDrawing = true;
                if (selectedDrawingIcon)
                {
                    selectedDrawingIcon.filters = [];
                    selectedDrawingIcon = null;
                }
            }

            private function widgetOpenedHandler(event:Event):void
            {
                if (resultFeatureLayer)
                {
                    if (shareResults)
                    {
                        map.addLayer(resultFeatureLayer);
                    }
                    else
                    {
                        resultFeatureLayer.visible = true;
                    }
                }
            }

            private function showStateGraphicalSearch():void
            {
                this.currentState = "graphicalInput";
                wTemplate.selectedTitlebarButtonIndex = 0;
            }

            private function showStateTextSearch():void
            {
                this.currentState = "textInput";
                wTemplate.selectedTitlebarButtonIndex = 1;
            }

            private function showStateResults():void
            {
                this.currentState = "resultsList";
                wTemplate.selectedTitlebarButtonIndex = 2;
            }

            private function iconRollOverHandler(event:MouseEvent):void
            {
                clearSelectionFilter();
                event.target.filters = [ glowFilter ];
            }

            private function iconRollOutHandler(event:MouseEvent):void
            {
                clearSelectionFilter();
            }

            private function clearSelectionFilter():void
            {
                for (var i:int = 0; i < imageGroup.numChildren; i++)
                {
                    if (imageGroup.getChildAt(i).filters && imageGroup.getChildAt(i).filters.length > 0)
                    {
                        if (!(selectedDrawingIcon && imageGroup.getChildAt(i) === selectedDrawingIcon))
                        {
                            imageGroup.getChildAt(i).filters = [];
                        }
                    }
                }
            }

            private function sharedDataUpdated(event:AppEvent):void
            {
                var data:Object = event.data;

                if (data.key == "Deactivate_DrawTool")
                {
                    setMapAction(null, null, null, null);
                    if (selectedDrawingIcon)
                    {
                        selectedDrawingIcon.filters = [];
                        selectedDrawingIcon = null;
                    }
                }
            }

            private function hideInfoWindow():void
            {
                if (map.infoWindow.contentOwner &&
                    ((map.infoWindow.contentOwner is Graphic && Graphic(map.infoWindow.contentOwner).graphicsLayer === resultFeatureLayer) || map.infoWindow.contentOwner is Map))
                {
                    map.infoWindow.hide();
                }
            }

            private function geometryService_faultHandler(event:FaultEvent):void
            {
                showError(event.fault.toString());
            }

            private function geometryService_simplifyCompleteHandler(event:GeometryServiceEvent):void
            {
                queryFeaturesGraphical(event.result[0] as Polygon);
            }
        ]]>
    </fx:Script>

    <fx:Declarations>
        <s:GlowFilter id="glowFilter"
                      alpha="1"
                      color="{getStyle('focusColor')}"
                      inner="true"
                      strength="2"/>
        <esri:GeometryService id="geometryService"
                              fault="geometryService_faultHandler(event)"
                              simplifyComplete="geometryService_simplifyCompleteHandler(event)"/>
    </fx:Declarations>

    <viewer:WidgetTemplate id="wTemplate"
                           closed="widgetClosedHandler(event)"
                           open="widgetOpenedHandler(event)"
                           visible="false">
        <s:Group id="graphicalInput"
                 width="100%" height="100%"
                 visible="false"
                 visible.graphicalInput="true">
            <s:layout>
                <s:VerticalLayout gap="10"
                                  horizontalAlign="center"
                                  paddingTop="4"/>
            </s:layout>
            <s:HGroup id="boxGraphical"
                      width="100%"
                      gap="15"
                      horizontalAlign="center"
                      verticalAlign="middle">
                <s:Label id="lblLayerGraphical" text="{layerLabel}"/>
                <s:DropDownList id="cboLayerGraphical"
                                change="searchLayerChangedGraphical()"
                                requireSelection="true"/>
            </s:HGroup>
            <s:Label id="txtLabelGraphical"
                     width="100%"
                     text=""
                     textAlign="center"/>
            <s:HGroup id="imageGroup"
                      width="100%"
                      gap="10"
                      horizontalAlign="center">
                <components:FocusableImage name="{DrawTool.MAPPOINT}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="iconRollOutHandler(event)"
                                           rollOver="iconRollOverHandler(event)"
                                           source="assets/images/i_draw_point.png"
                                           toolTip="{pointLabel}"
                                           useHandCursor="true"/>
                <components:FocusableImage name="{DrawTool.POLYLINE}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="iconRollOutHandler(event)"
                                           rollOver="iconRollOverHandler(event)"
                                           source="assets/images/i_draw_line.png"
                                           toolTip="{lineLabel}"
                                           useHandCursor="true"/>
                <components:FocusableImage name="{DrawTool.FREEHAND_POLYLINE}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="iconRollOutHandler(event)"
                                           rollOver="iconRollOverHandler(event)"
                                           source="assets/images/i_draw_freeline.png"
                                           toolTip="{freehandLineLabel}"
                                           useHandCursor="true"/>
                <components:FocusableImage name="{DrawTool.EXTENT}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="iconRollOutHandler(event)"
                                           rollOver="iconRollOverHandler(event)"
                                           source="assets/images/i_draw_rect.png"
                                           toolTip="{rectangleLabel}"
                                           useHandCursor="true"/>
                <components:FocusableImage name="{DrawTool.CIRCLE}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="iconRollOutHandler(event)"
                                           rollOver="iconRollOverHandler(event)"
                                           source="assets/images/i_draw_circle.png"
                                           toolTip="{circleLabel}"
                                           useHandCursor="true"/>
                <components:FocusableImage name="{DrawTool.POLYGON}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="iconRollOutHandler(event)"
                                           rollOver="iconRollOverHandler(event)"
                                           source="assets/images/i_draw_poly.png"
                                           toolTip="{polygonLabel}"
                                           useHandCursor="true"/>
                <components:FocusableImage name="{DrawTool.FREEHAND_POLYGON}"
                                           width="40" height="40"
                                           buttonMode="true"
                                           click="activateDrawTool(event)"
                                           rollOut="iconRollOutHandler(event)"
                                           rollOver="iconRollOverHandler(event)"
                                           source="assets/images/i_draw_freepoly.png"
                                           toolTip="{freehandPolygonLabel}"
                                           useHandCursor="true"/>
            </s:HGroup>
            <s:HGroup id="clearGroup"
                      width="100%"
                      horizontalAlign="right"
                      paddingRight="10"
                      paddingTop="2">
                <s:Label buttonMode="true"
                         click="clear()"
                         fontWeight="bold"
                         text="{clearLabel}"
                         textDecoration="underline"/>
            </s:HGroup>
        </s:Group>
        <s:Group id="textInput"
                 width="100%" height="100%"
                 visible="false"
                 visible.textInput="true">
            <s:layout>
                <s:VerticalLayout gap="10"
                                  horizontalAlign="center"
                                  paddingTop="4"/>
            </s:layout>
            <s:HGroup id="boxText"
                      width="100%"
                      gap="15"
                      horizontalAlign="center"
                      verticalAlign="middle">
                <s:Label id="lblLayerText" text="{layerLabel}"/>
                <s:DropDownList id="cboLayerText"
                                change="searchLayerChangedText()"
                                requireSelection="true"/>
            </s:HGroup>
            <s:RichEditableText id="txtLabelText"
                                width="100%"
                                editable="false"
                                text=""
                                textAlign="center"/>
            <s:TextInput id="txtSearch"
                         width="90%"
                         enter="queryFeaturesText()"/>
            <s:HGroup width="100%" horizontalAlign="center">
                <s:Button click="queryFeaturesText()" label="{submitLabel}"/>
                <s:Button click="clear()" label="{clearLabel}"/>
            </s:HGroup>
        </s:Group>
        <s:Group id="resultsList"
                 width="100%" height="100%"
                 visible="false"
                 visible.resultsList="true">
            <s:layout>
                <s:VerticalLayout gap="1" paddingTop="4"/>
            </s:layout>
            <s:HGroup id="boxMessage"
                      width="100%"
                      includeInLayout="{msgVisible}"
                      visible="{msgVisible}">
                <mx:Image id="swfMessage"
                          source="assets/images/loader.swf"
                          visible="false"/>
                <s:Label id="txtMessage"
                         width="98%"
                         text=""/>
            </s:HGroup>
            <s:Scroller width="100%" height="100%">
                <Search:SearchResultDataGroup dataProvider="{searchResultAC}"
                                              searchResultClick="clickSearchResult(event)"
                                              searchResultMouseOut="mouseOutSearchResult(event)"
                                              searchResultMouseOver="mouseOverSearchResult(event)">
                    <Search:layout>
                        <s:VerticalLayout gap="2"
                                          horizontalAlign="justify"
                                          useVirtualLayout="true"/>
                    </Search:layout>
                </Search:SearchResultDataGroup>
            </s:Scroller>
        </s:Group>
    </viewer:WidgetTemplate>
</viewer:BaseWidget>
