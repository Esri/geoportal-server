<?xml version="1.0" encoding="utf-8"?>
<!--
///////////////////////////////////////////////////////////////////////////
// Copyright (c) 2010-2011 Esri. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
///////////////////////////////////////////////////////////////////////////
-->
<viewer:BaseWidget xmlns:fx="http://ns.adobe.com/mxml/2009"
                   xmlns:s="library://ns.adobe.com/flex/spark"
                   xmlns:mx="library://ns.adobe.com/flex/mx"
                   xmlns:esri="http://www.esri.com/2008/ags"
                   xmlns:viewer="com.esri.viewer.*"
                   creationComplete="basewidget_creationCompleteHandler(event)"
                   initialize="basewidget_initializeHandler()"
                   widgetConfigLoaded="basewidget_widgetConfigLoaded()">

    <fx:Style>
        @namespace esri "http://www.esri.com/2008/ags";

        esri|TemplatePicker
        {
            skin-class: ClassReference("widgets.Edit.EditWidgetTemplatePickerSkin");
        }
    </fx:Style>

    <fx:Script>
        <![CDATA[
            import com.esri.ags.Graphic;
            import com.esri.ags.components.AttributeInspector;
            import com.esri.ags.components.supportClasses.FieldInspector;
            import com.esri.ags.events.AttributeInspectorEvent;
            import com.esri.ags.events.FeatureLayerEvent;
            import com.esri.ags.events.LayerEvent;
            import com.esri.ags.events.MapEvent;
            import com.esri.ags.layers.ArcGISDynamicMapServiceLayer;
            import com.esri.ags.layers.ArcGISTiledMapServiceLayer;
            import com.esri.ags.layers.FeatureLayer;
            import com.esri.ags.layers.GraphicsLayer;
            import com.esri.ags.layers.Layer;
            import com.esri.ags.layers.supportClasses.FeatureLayerDetails;
            import com.esri.ags.layers.supportClasses.FeatureTableDetails;
            import com.esri.ags.layers.supportClasses.Field;
            import com.esri.ags.layers.supportClasses.LayerInfo;
            import com.esri.ags.skins.fieldClasses.CalendarField;
            import com.esri.ags.skins.supportClasses.AttachmentMouseEvent;
            import com.esri.ags.tasks.GeometryServiceSingleton;
            import com.esri.ags.tasks.JSONTask;
            import com.esri.viewer.AppEvent;
            import com.esri.viewer.utils.MapServiceUtil;

            import mx.binding.utils.ChangeWatcher;
            import mx.collections.ArrayCollection;
            import mx.core.FlexGlobals;
            import mx.events.CollectionEvent;
            import mx.events.FlexEvent;
            import mx.rpc.AsyncResponder;
            import mx.rpc.Fault;

            [Bindable]
            private var oplList:Array;
            [Bindable]
            private var featureLayers:Array;
            private var arrLayers:Array;
            private var arrFinalLayers:Array;
            private var mapLayers:ArrayCollection;

            private var addFeatures:Boolean = true;
            private var deleteFeatures:Boolean = true;
            private var updateGeometry:Boolean = true;
            private var updateAttributes:Boolean = true;
            private var dictionary:Dictionary = new Dictionary /*layer,renderer*/;
            private var featureLayerToDynamicMapService:Dictionary = new Dictionary /*FeatureLayer,ArcGISDynamicMapServiceLayer*/;
            private var hiddenFeatureLayerToSettingsName:Dictionary = new Dictionary /*FeatureLayer,String*/;
            private var excludeLayers:Array;
            private var lastState:String;

            private var disablePanZoomNavigationWidget:Boolean;

            private var attributesLabel:String;
            [Bindable]
            private var attachmentsLabel:String;
            [Bindable]
            private var relatedRecordsLabel:String;

            [Bindable]
            private var showAttributesText:String;
            [Bindable]
            private var noEditableLayersText:String;

            private var visibleLayersChangeWatcher:ChangeWatcher;
            private var activeFeatureChangeWatcher:ChangeWatcher;
            private var layerToSettings:Dictionary = new Dictionary /*layer,settingsObject*/;

            private function basewidget_initializeHandler():void
            {
                if (isPartOfPanel) // if widget is part of "left", "right" or "bottom" panel
                {
                    this.percentWidth = this.percentHeight = 100;
                    wTemplate.percentWidth = wTemplate.percentHeight = 100;
                }
                else
                {
                    wTemplate.width = 310;
                    wTemplate.height = 310;
                }
            }

            private function basewidget_widgetConfigLoaded():void
            {
                // hide map infowindow if any
                map.infoWindow.hide();

                if (configXML)
                {
                    if (GeometryServiceSingleton.instance.url) // using GeometryServiceSingleton
                    {
                        geometryService.url = GeometryServiceSingleton.instance.url;
                        geometryService.token = GeometryServiceSingleton.instance.token;
                        geometryService.proxyURL = GeometryServiceSingleton.instance.proxyURL;
                    }
                    else if (configXML.geometryservice.length() > 0) // look in widget's config if not using GeometryServiceSingleton
                    {
                        geometryService.url = configXML.geometryservice;
                    }

                    editor.toolbarVisible = configXML.toolbarvisible == "true";

                    const configToolbarCutVisible:Boolean = configXML.toolbarcutvisible == "true";
                    editor.toolbarCutVisible = configToolbarCutVisible;

                    const configToolbarMergeVisible:Boolean = configXML.toolbarmergevisible == "true";
                    editor.toolbarMergeVisible = configToolbarMergeVisible;

                    const configToolbarReshapeVisible:Boolean = configXML.toolbarreshapevisible == "true";
                    editor.toolbarReshapeVisible = configToolbarReshapeVisible;

                    if (configXML.createoptions.length() > 0)
                    {
                        createOptions.polygonDrawTools = new Array();
                        createOptions.polylineDrawTools = new Array();

                        if (configXML.createoptions.polygondrawtools.length() > 0)
                        {
                            const polygonDrawToolsList:Array = configXML.createoptions.polygondrawtools.split(",");
                            for (var i:Number = 0; i < polygonDrawToolsList.length; i++)
                            {
                                createOptions.polygonDrawTools.push(polygonDrawToolsList[i]);
                            }
                        }

                        if (configXML.createoptions.polylinedrawtools.length() > 0)
                        {
                            const polylineDrawToolsList:Array = configXML.createoptions.polylinedrawtools.split(",");
                            for (var j:Number = 0; j < polylineDrawToolsList.length; j++)
                            {
                                createOptions.polylineDrawTools.push(polylineDrawToolsList[j]);
                            }
                        }
                        editor.createOptions = createOptions;
                    }
                    //excludeLayers
                    excludeLayers = [];
                    var layers:XMLList = configXML.excludelayer as XMLList;
                    for (var n:Number = 0; n < layers.length(); n++)
                    {
                        excludeLayers.push(layers[n].toString());
                    }

                    //deleteFeatures
                    if (configXML.deletefeatures.length() > 0)
                    {
                        deleteFeatures = configXML.deletefeatures == "true";
                    }
                    editor.deleteEnabled = attachmentInspector.deleteEnabled = deleteFeatures;

                    //addFeatures
                    if (configXML.addfeatures.length() > 0)
                    {
                        addFeatures = configXML.addfeatures == "true";
                    }
                    editor.addEnabled = addFeatures;

                    //updateAttributes
                    if (configXML.updateattributes.length() > 0)
                    {
                        updateAttributes = configXML.updateattributes == "true";
                    }
                    editor.updateAttributesEnabled = updateAttributes;

                    //updateGeometry
                    if (configXML.updategeometry.length() > 0)
                    {
                        updateGeometry = configXML.updategeometry == "true";
                    }
                    editor.updateGeometryEnabled = updateGeometry;

                    if (configXML.layersettings.length() > 0)
                    {
                        // layerSettings, overriding default settings
                        configureLayerSettings(configXML.layersettings.layer);
                    }
                    else if (configXML.formfieldsorder.length() > 0)
                    {
                        // formFieldsOrder - applies to all layers
                        editor.attributeInspector.formFieldsOrder = toAttributeInspectorFormFieldsOrder(configXML.formfieldsorder);
                    }

                    //labels
                    configureLabels(configXML.labels);
                }
                map.addEventListener(MapEvent.LAYER_ADD, mapLayerAddHandler, false);
                map.addEventListener(MapEvent.LAYER_REMOVE, mapLayerRemoveHandler, false);
                map.addEventListener(MapEvent.LAYER_REORDER, mapLayerReorderHandler, false);
                map.infoWindow.addEventListener(Event.CLOSE, infoWindowCloseHandler);

                AppEvent.dispatch(AppEvent.DATA_OPT_LAYERS, null, getOplayers);
                mapLayers = map.layers as ArrayCollection;
                arrLayers = getLayers(mapLayers); // get all the layers on map except basemap layers;
                populateEditor(arrLayers);
            }

            private function configureLayerSettings(layers:XMLList):void
            {
                for (var l:int = 0; l < layers.length(); l++)
                {
                    var layerXML:XML = layers[l] as XML;

                    var layerName:String = layerXML.@name[0];
                    var subLayers:XMLList = layerXML.sublayer; // for configuring sublayers in a dynamic map service
                    if (subLayers.length() > 0)
                    {
                        for each (var subLayerXML:XML in subLayers)
                        {
                            var subLayerId:String = subLayerXML.@id[0];
                            layerToSettings[layerName + "/" + subLayerId] = getLayerSettings(subLayerXML);
                        }
                    }
                    else
                    {
                        layerToSettings[layerName] = getLayerSettings(layerXML);
                    }
                }
            }

            private function getLayerSettings(layerXML:XML):Object
            {
                var layerSettings:Object = {};

                var layerFields:XMLList = layerXML.fields;
                if (layerFields.length() > 0)
                {
                    var outFields:Array = [];
                    var fields:XMLList = layerFields.field;
                    for each (var fieldXML:XML in fields)
                    {
                        if (fieldXML.@name[0])
                        {
                            var fieldObject:Object = {};
                            fieldObject.name = fieldXML.@name;
                            if (fieldXML.@alias[0])
                            {
                                fieldObject.alias = fieldXML.@alias;
                            }
                            if (fieldXML.@tooltip[0])
                            {
                                fieldObject.tooltip = fieldXML.@tooltip;
                            }
                            if (fieldXML.@dateformat[0])
                            {
                                fieldObject.dateFormat = fieldXML.@dateformat;
                            }
                            if (fieldXML.@useutc[0])
                            {
                                fieldObject.useUTC = fieldXML.@useutc == "true";
                            }
                            if (fieldXML.@required[0])
                            {
                                fieldObject.required = fieldXML.@required == "true";
                            }
                            outFields.push(fieldObject);
                        }
                    }
                    layerSettings.outFields = outFields;
                }
                if (layerXML.singletomultilinethreshold.length() > 0)
                {
                    layerSettings.singleToMultilineThreshold = layerXML.singletomultilinethreshold;
                }
                if (layerXML.formfieldsorder.length() > 0)
                {
                    layerSettings.formFieldsOrder = toAttributeInspectorFormFieldsOrder(layerXML.formfieldsorder);
                }
                if (layerXML.showobjectid.length() > 0)
                {
                    layerSettings.showObjectID = layerXML.showobjectid;
                }
                if (layerXML.showglobalid.length() > 0)
                {
                    layerSettings.showGlobalID = layerXML.showglobalid;
                }

                return layerSettings;
            }

            private function toAttributeInspectorFormFieldsOrder(formFieldsOrder:String):String
            {
                switch (formFieldsOrder)
                {
                    case "alphabetical":
                    {
                        return AttributeInspector.ALPHABETICAL_ORDER;
                    }
                    case "fieldinspector":
                    {
                        return AttributeInspector.FIELD_INSPECTOR_ORDER;
                    }
                    case "fields":
                    default:
                    {
                        return AttributeInspector.FIELDS_ORDER;
                    }
                }
            }

            private function configureLabels(labels:XMLList):void
            {
                attributesLabel = labels.attributeslabel[0] || getDefaultString("attributesLabel");
                attachmentsLabel = labels.attachmentslabel[0] || getDefaultString("attachmentsLabel");
                relatedRecordsLabel = labels.relatedrecordslabel[0] || getDefaultString("relatedRecordsLabel");
                noEditableLayersText = labels.noeditablelayerstext[0] || getDefaultString("noEditableLayersText");

                EditWidgetTemplatePickerSkin.featureLayerOutOfScaleText = labels.featurelayeroutofscaletext[0] || getDefaultString("featureLayerOutOfScaleText");

                EditWidgetAttributeInspectorSkin.showAttachmentsText = labels.showattachmentstext[0] || getDefaultString("showAttachmentsText");
                EditWidgetAttributeInspectorSkin.showRelatedRecordsText = labels.showrelatedrecordstext[0] || getDefaultString("showRelatedRecordsText");
                EditWidgetAttributeInspectorSkin.deleteLabel = labels.deletelabel[0] || getDefaultString("deleteLabel");
                EditWidgetAttributeInspectorSkin.saveLabel = labels.savelabel[0] || getDefaultString("okLabel");

                EditWidgetAttachmentInspectorSkin.noAttachmentsText = labels.noattchmentstext[0] || getDefaultString("noAttachmentsText");
                EditWidgetAttachmentInspectorSkin.chooseFileText = labels.choosefiletext[0] || getDefaultString("chooseFileText");
                EditWidgetAttachmentInspectorSkin.attachmentSubmitLabel = labels.attachmentsubmitlabel[0] || getDefaultString("attachmentSubmitLabel");
                EditWidgetAttachmentInspectorSkin.attachmentCancelLabel = labels.attachmentcancellabel[0] || getDefaultString("attachmentCancelLabel");
                EditWidgetAttachmentInspectorSkin.showAttributesText = labels.showattributestext[0] || getDefaultString("showAttributesText");

                EditWidgetRelationshipInspectorSkin.showAttributesText = labels.showattributestext[0] || getDefaultString("showAttributesText");
            }

            private function basewidget_creationCompleteHandler(event:FlexEvent):void
            {
                // do not show template swatch for RTL
                editor.showTemplateSwatchOnCursor = FlexGlobals.topLevelApplication.layoutDirection != "rtl";

                editor.attributeInspector.setStyle("skinClass", EditWidgetAttributeInspectorSkin);
                editor.attributeInspector.addEventListener("attachmentGroupClicked", attachmentGroupClickedHandler);
                editor.attributeInspector.addEventListener("relatedRecordsGroupClicked", relatedRecordsGroupClickedHandler);
                editor.attributeInspector.addEventListener(AttributeInspectorEvent.SHOW_FEATURE, attributeInspector_showFeatureHandler);

                attachmentInspector.addEventListener("attributeGroupClicked", attributeGroupClickedHandler);
                relationshipInspector.addEventListener("attributeGroupClicked", attributeGroupClickedHandler);
            }

            private function getOplayers(event:AppEvent):void
            {
                oplList = event.data as Array;
            }

            private function getLayers(layers:ArrayCollection):Array
            {
                // all the layers except basemaps
                var result:Array = [];
                var includeLayer:Boolean;
                var dynamicBaseMapLayers:Array = [];
                for (var i:int = layers.length - 1; i >= 0; i--)
                {
                    includeLayer = true;
                    var layer:Layer = layers.getItemAt(i) as Layer;
                    for (var n:int = 0; n < configData.basemaps.length; )
                    {
                        if (configData.basemaps[n].label == layer.id)
                        {
                            if (layer is ArcGISDynamicMapServiceLayer)
                            {
                                dynamicBaseMapLayers.push(layer);
                            }
                            includeLayer = false;
                            break;
                        }
                        else
                        {
                            n++;
                        }
                    }
                    if (includeLayer && !isLayerPartOfExcludeLayers(layer.name) && (layer is FeatureLayer || layer is ArcGISDynamicMapServiceLayer))
                    {
                        result.push(layer);
                    }
                }
                for each (var dynamicBaseMapLayer:ArcGISDynamicMapServiceLayer in dynamicBaseMapLayers.reverse())
                {
                    if (!isLayerPartOfExcludeLayers(dynamicBaseMapLayer.name))
                    {
                        result.push(dynamicBaseMapLayer);
                    }
                }
                return result;
            }

            private function populateEditor(array:Array):void
            {
                featureLayers = [];
                arrFinalLayers = [];
                if (array && array.length)
                {
                    var index:int = 0;
                    getAllFeatureLayers(index, featureLayers);
                }
            }

            private function getAllFeatureLayers(index:int, featureLayers:Array):void
            {
                if (index < arrLayers.length)
                {
                    var layer:Layer = arrLayers[index] as Layer;
                    if (layer.loaded)
                    {
                        if ((layer is FeatureLayer && layer.name.indexOf("hiddenLayer_") == -1) && FeatureLayer(layer).isEditable && !FeatureLayer(layer).featureCollection)
                        {
                            layer.removeEventListener(FeatureLayerEvent.SELECTION_COMPLETE, featureLayer_selectionComplete);
                            layer.addEventListener(FeatureLayerEvent.SELECTION_COMPLETE, featureLayer_selectionComplete, false, 1);
                            featureLayers.push(layer);
                            arrFinalLayers.push(layer);

                            index++;
                            getAllFeatureLayers(index, featureLayers);
                        }
                        else if (layer is ArcGISDynamicMapServiceLayer && layer.name.indexOf("hiddenLayer_") == -1)
                        {
                            createFeatureLayersFromDynamicMapService(ArcGISDynamicMapServiceLayer(layer), index);
                        }
                        else
                        {
                            index++;
                            getAllFeatureLayers(index, featureLayers);
                        }
                    }
                    else if (layer.loadFault)
                    {
                        index++;
                        getAllFeatureLayers(index, featureLayers);
                    }
                    else
                    {
                        // listen for load
                        layer.addEventListener(LayerEvent.LOAD, layerLoadHandler);
                    }
                }
                else
                {
                    deactivateEditor();
                    if (featureLayers.length > 0)
                    {
                        noLayers.visible = noLayers.includeInLayout = false;
                        selectTemplateLabel.visible = selectTemplateLabel.includeInLayout = true;
                        if (!editor.addEnabled || !atleastOneFeatureLayerHasCreateCapability(featureLayers))
                        {
                            selectTemplateLabel.text = getDefaultString("noCreateCapabilityLayersText");
                        }

                        //store the renderer info for each layer on map
                        storeInfoWindowRenderer();
                        editor.map = map;
                        editor.featureLayers = featureLayers;
                        // infowindowLabel on the AttributeInspector
                        editor.attributeInspector.infoWindowLabel = attributesLabel;
                    }
                    else
                    {
                        selectTemplateLabel.visible = selectTemplateLabel.includeInLayout = false;
                        noLayers.visible = noLayers.includeInLayout = true;
                        editor.toolbarVisible = false;
                    }
                }
            }

            private function layerLoadHandler(event:LayerEvent):void
            {
                getAllFeatureLayers(arrLayers.indexOf(event.layer), featureLayers);
            }

            private function createFeatureLayersFromDynamicMapService(layer:ArcGISDynamicMapServiceLayer, index:int, onMapLayerAdd:Boolean = false):void
            {
                // look at the url
                var serviceURL:String = layer.url;
                var gdbVersion:String = layer.gdbVersion;
                var featureServiceURL:String = serviceURL.replace(/MapServer/i, "FeatureServer");

                // get corresponding featurelayers
                var jsonTask:JSONTask = new JSONTask;
                var urlVars:URLVariables = new URLVariables();
                urlVars.f = "json";
                jsonTask.proxyURL = layer.proxyURL;
                jsonTask.token = layer.token;
                jsonTask.url = featureServiceURL;
                jsonTask.execute(urlVars, new AsyncResponder(jsonTask_resultHandler, jsonTask_faultHandler, { layer: layer, count: index }));

                function jsonTask_resultHandler(resultObject:Object, token:Object = null):void
                {
                    const layers:Array = resultObject.layers;
                    if (layers && layers.length)
                    {
                        var arcGISDynamicMapServiceLayer:ArcGISDynamicMapServiceLayer = ArcGISDynamicMapServiceLayer(token.layer);

                        var atleastOneFeatureLayerAlreadyIncluded:Boolean;
                        var candidateFeatureLayers:Array = [];
                        for (var i:int = 0; i < layers.length; )
                        {
                            if (isFeatureLayerPartOfOpList(featureServiceURL + "/" + layers[i].id, gdbVersion))
                            {
                                atleastOneFeatureLayerAlreadyIncluded = true;
                                break;
                            }
                            else
                            {
                                if (!isLayerPartOfExcludeLayers(arcGISDynamicMapServiceLayer.name + "/" + layers[i].id))
                                {
                                    candidateFeatureLayers.push(layers[i]);
                                }
                                i++;
                            }
                        }
                        if (!atleastOneFeatureLayerAlreadyIncluded && candidateFeatureLayers.length)
                        {
                            arcGISDynamicMapServiceLayer.removeEventListener(LayerEvent.IS_IN_SCALE_RANGE_CHANGE, layer_isInScaleRangeChangeHandler);
                            arcGISDynamicMapServiceLayer.removeEventListener(FlexEvent.HIDE, layer_hideShowHandler);
                            arcGISDynamicMapServiceLayer.removeEventListener(FlexEvent.SHOW, layer_hideShowHandler);

                            arcGISDynamicMapServiceLayer.addEventListener(LayerEvent.IS_IN_SCALE_RANGE_CHANGE, layer_isInScaleRangeChangeHandler);
                            arcGISDynamicMapServiceLayer.addEventListener(FlexEvent.HIDE, layer_hideShowHandler);
                            arcGISDynamicMapServiceLayer.addEventListener(FlexEvent.SHOW, layer_hideShowHandler);

                            var copyLayerInfos:Array = arcGISDynamicMapServiceLayer.layerInfos;
                            if (!arcGISDynamicMapServiceLayer.visibleLayers)
                            {
                                var visLayers:Array = getActualVisibleLayers(MapServiceUtil.getVisibleSubLayers(copyLayerInfos), copyLayerInfos);
                                arcGISDynamicMapServiceLayer.visibleLayers = new ArrayCollection(visLayers);
                            }
                            arcGISDynamicMapServiceLayer.visibleLayers.addEventListener(CollectionEvent.COLLECTION_CHANGE, visibleLayersChangeHandler);
                            visibleLayersChangeWatcher = ChangeWatcher.watch(arcGISDynamicMapServiceLayer, "visibleLayers", visibleLayersChange);
                            for each (var copyLayerInfo:LayerInfo in copyLayerInfos)
                            {
                                updateMinMaxScaleOnLayerInfos(copyLayerInfo, copyLayerInfos);
                            }

                            var arr:Array = [];
                            var index1:int = 0;
                            parseCandidateFeatureLayers(index1, candidateFeatureLayers);

                            var fLayerObject:Object;
                            function parseCandidateFeatureLayers(index1:int, candidateFeatureLayers:Array):void
                            {
                                if (index1 < candidateFeatureLayers.length)
                                {
                                    fLayerObject = candidateFeatureLayers[index1];
                                    var featureLayerFromMap:FeatureLayer = getFeatureLayerFromMap(featureServiceURL + "/" + fLayerObject.id, gdbVersion);
                                    if (!featureLayerFromMap)
                                    {
                                        var featureLayer:FeatureLayer = new FeatureLayer;
                                        featureLayer.proxyURL = arcGISDynamicMapServiceLayer.proxyURL;
                                        featureLayer.token = arcGISDynamicMapServiceLayer.token;
                                        featureLayer.url = featureServiceURL + "/" + fLayerObject.id;
                                        updateFeatureLayerMinMaxScale(featureLayer, fLayerObject.id, copyLayerInfos);
                                        featureLayer.addEventListener(LayerEvent.LOAD, featureLayerLoadHandler);
                                        featureLayer.addEventListener(LayerEvent.LOAD_ERROR, featureLayerLoadErrorHandler);
                                    }
                                    else
                                    {
                                        featureLayerFromMap.addEventListener(FlexEvent.HIDE, featureLayer_hideShowHandler);
                                        featureLayerFromMap.addEventListener(FlexEvent.SHOW, featureLayer_hideShowHandler);
                                        featureLayerToDynamicMapService[featureLayerFromMap] = arcGISDynamicMapServiceLayer;
                                        if (!onMapLayerAdd)
                                        {
                                            featureLayers.push(featureLayerFromMap);
                                        }
                                        else
                                        {
                                            featureLayers.unshift(featureLayerFromMap);
                                        }
                                        index1++;
                                        parseCandidateFeatureLayers(index1, candidateFeatureLayers);
                                    }
                                }
                                else
                                {
                                    var indexOnMap:int = map.layerIds.indexOf(arcGISDynamicMapServiceLayer.id) + 1;
                                    for each (var featLayer:FeatureLayer in arr.reverse())
                                    {
                                        map.addLayer(featLayer, indexOnMap);
                                        indexOnMap++;
                                    }
                                    arrFinalLayers.push(arcGISDynamicMapServiceLayer);
                                    if (!onMapLayerAdd)
                                    {
                                        index = token.count + 1;
                                        getAllFeatureLayers(index, featureLayers);
                                    }
                                    else
                                    {
                                        deactivateEditor();
                                        editor.featureLayers = featureLayers;
                                        //store the renderer info for each layer on map
                                        storeInfoWindowRenderer();
                                    }
                                }
                            }

                            function featureLayerLoadHandler(event:LayerEvent):void
                            {
                                var loadedFeatureLayer:FeatureLayer = event.layer as FeatureLayer;
                                if (loadedFeatureLayer.isEditable)
                                {
                                    loadedFeatureLayer.outFields = [ '*' ];
                                    loadedFeatureLayer.mode = FeatureLayer.MODE_SELECTION;
                                    loadedFeatureLayer.gdbVersion = gdbVersion;
                                    loadedFeatureLayer.name = "hiddenLayer_" + fLayerObject.name;
                                    if (gdbVersion)
                                    {
                                        loadedFeatureLayer.name += "-" + gdbVersion;
                                    }
                                    if (arcGISDynamicMapServiceLayer.visible)
                                    {
                                        loadedFeatureLayer.visible = arcGISDynamicMapServiceLayer.visibleLayers ? isFeatureLayerVisible(fLayerObject.id, arcGISDynamicMapServiceLayer) : isFeatureLayerVisible(fLayerObject.id, arcGISDynamicMapServiceLayer, true);
                                    }
                                    else
                                    {
                                        loadedFeatureLayer.visible = false;
                                    }

                                    loadedFeatureLayer.removeEventListener(FlexEvent.HIDE, featureLayer_hideShowHandler);
                                    loadedFeatureLayer.removeEventListener(FlexEvent.SHOW, featureLayer_hideShowHandler);
                                    loadedFeatureLayer.removeEventListener(FeatureLayerEvent.SELECTION_COMPLETE, featureLayer_selectionComplete);

                                    loadedFeatureLayer.addEventListener(FlexEvent.HIDE, featureLayer_hideShowHandler);
                                    loadedFeatureLayer.addEventListener(FlexEvent.SHOW, featureLayer_hideShowHandler);
                                    loadedFeatureLayer.addEventListener(FeatureLayerEvent.SELECTION_COMPLETE, featureLayer_selectionComplete, false, 1);

                                    featureLayerToDynamicMapService[loadedFeatureLayer] = arcGISDynamicMapServiceLayer;

                                    if (!onMapLayerAdd)
                                    {
                                        featureLayers.push(loadedFeatureLayer);
                                    }
                                    else
                                    {
                                        featureLayers.unshift(loadedFeatureLayer);
                                    }
                                    arr.push(loadedFeatureLayer);
                                }
                                index1++;
                                parseCandidateFeatureLayers(index1, candidateFeatureLayers);
                            }

                            function featureLayerLoadErrorHandler(event:LayerEvent):void
                            {
                                index1++;
                                parseCandidateFeatureLayers(index1, candidateFeatureLayers);
                            }
                        }
                        else
                        {
                            index = token.count + 1;
                            getAllFeatureLayers(index, featureLayers);
                        }
                    }
                    else
                    {
                        index = token.count + 1;
                        getAllFeatureLayers(index, featureLayers);
                    }
                }
                function jsonTask_faultHandler(fault:Fault, token:Object = null):void
                {
                    if (!onMapLayerAdd)
                    {
                        index = token.count + 1;
                        getAllFeatureLayers(index, featureLayers);
                    }
                }
            }

            private function updateMinMaxScaleOnLayerInfos(copyLayerInfo:LayerInfo, copyLayerInfos:Array):void
            {
                if (copyLayerInfo.subLayerIds)
                {
                    for each (var childId:Number in copyLayerInfo.subLayerIds)
                    {
                        var childLayer:LayerInfo = findLayerById(childId, copyLayerInfos);
                        if (childLayer)
                        {
                            if (copyLayerInfo.minScale > 0)
                            {
                                if (childLayer.minScale == 0 || (childLayer.minScale > 0 && childLayer.minScale > copyLayerInfo.minScale))
                                {
                                    childLayer.minScale = copyLayerInfo.minScale;
                                }
                            }
                            if (copyLayerInfo.maxScale)
                            {
                                if (childLayer.maxScale == 0 || (childLayer.maxScale > 0 && childLayer.maxScale < copyLayerInfo.maxScale))
                                {
                                    childLayer.maxScale = copyLayerInfo.maxScale;
                                }
                            }
                        }
                    }
                }
            }

            private function updateFeatureLayerMinMaxScale(featureLayer:FeatureLayer, layerId:Number, copyLayerInfos:Array):void
            {
                for each (var copyLayerInfo:LayerInfo in copyLayerInfos)
                {
                    if (copyLayerInfo.layerId == layerId)
                    {
                        featureLayer.minScale = copyLayerInfo.minScale;
                        featureLayer.maxScale = copyLayerInfo.maxScale;
                        break;
                    }
                }
            }

            private function changeOplListObjectVisibility(layer:Layer):void
            {
                for (var i:int = 0; i < oplList.length; )
                {
                    if (oplList[i].layer == layer)
                    {
                        oplList[i].visible = true;
                        AppEvent.dispatch(AppEvent.MAP_LAYER_VISIBLE, oplList[i]);
                        break;
                    }
                    else
                    {
                        i++;
                    }
                }
            }

            private function mapLayerAddHandler(event:MapEvent):void
            {
                if (event.layer.name.indexOf("hiddenLayer_") == -1)
                {
                    if (event.layer is FeatureLayer)
                    {
                        event.layer.visible = true;
                        changeOplListObjectVisibility(event.layer);
                        event.layer.removeEventListener(FeatureLayerEvent.SELECTION_COMPLETE, featureLayer_selectionComplete);
                        event.layer.addEventListener(FeatureLayerEvent.SELECTION_COMPLETE, featureLayer_selectionComplete, false, 1);

                        //store the renderer info for each layer on map
                        storeInfoWindowRenderer();

                        arrFinalLayers.unshift(event.layer);
                        featureLayers.unshift(event.layer);
                        deactivateEditor();
                        editor.map = map;
                        editor.featureLayers = featureLayers;
                    }
                    else if (event.layer is ArcGISDynamicMapServiceLayer)
                    {
                        event.layer.visible = true;
                        createFeatureLayersFromDynamicMapService(ArcGISDynamicMapServiceLayer(event.layer), 0, true);
                    }
                }
            }

            private function mapLayerRemoveHandler(event:MapEvent):void
            {
                var index:int = arrFinalLayers.indexOf(event.layer);
                if (index != -1)
                {
                    if (event.layer is ArcGISDynamicMapServiceLayer)
                    {
                        for each (var fl:FeatureLayer in featureLayers)
                        {
                            if (fl.name.indexOf("hiddenLayer_") != -1 && featureLayerToDynamicMapService[fl] == event.layer)
                            {
                                map.removeLayer(fl);
                                featureLayers.splice(featureLayers.indexOf(fl), 1);
                            }
                        }
                    }
                    else if (event.layer is FeatureLayer)
                    {
                        for each (var fl1:FeatureLayer in featureLayers)
                        {
                            if (fl1 == event.layer)
                            {
                                featureLayers.splice(featureLayers.indexOf(fl1), 1);
                            }
                        }
                    }
                    delete arrFinalLayers[index];
                    deactivateEditor();
                    editor.map = map;
                    editor.featureLayers = featureLayers;
                }
            }

            private function mapLayerReorderHandler(event:MapEvent):void
            {
                var layer:Layer = event.layer;
                var index:int = event.index;

                var i:int;
                var currentFeatureLayerIndex:int;
                var newLayerIds:Array = getNewLayerIds(map.layerIds);
                if (index <= (newLayerIds.length - arrFinalLayers.length))
                {
                    if (layer is FeatureLayer && featureLayers.indexOf(layer) != -1)
                    {
                        moveFeatureLayerToTheBottom(FeatureLayer(layer));
                    }
                    else if (layer is ArcGISDynamicMapServiceLayer)
                    {
                        var arr:Array = [];
                        for each (var fl:FeatureLayer in featureLayers)
                        {
                            if (fl.name.indexOf("hiddenLayer_") != -1 && featureLayerToDynamicMapService[fl] == layer)
                            {
                                arr.push(fl);
                            }
                        }
                        if (arr.length)
                        {
                            for each (var fl1:FeatureLayer in arr)
                            {
                                moveFeatureLayerToTheBottom(fl1);
                            }
                        }
                    }
                }
                else if ((newLayerIds.length - arrFinalLayers.length < index) && (index < newLayerIds.length))
                {
                    if (layer is FeatureLayer && featureLayers.indexOf(layer) != -1)
                    {
                        moveFeatureLayer(FeatureLayer(layer));
                    }
                    else if (layer is ArcGISDynamicMapServiceLayer)
                    {
                        var arr1:Array = [];
                        for each (var fLayer:FeatureLayer in featureLayers)
                        {
                            if (fLayer.name.indexOf("hiddenLayer_") != -1 && featureLayerToDynamicMapService[fLayer] == layer)
                            {
                                arr1.push(fLayer);
                            }
                        }
                        if (arr1.length)
                        {
                            for each (var fLayer1:FeatureLayer in arr1)
                            {
                                moveFeatureLayer(fLayer1);
                            }
                        }
                    }
                }
                deactivateEditor();
                editor.map = map;
                editor.featureLayers = featureLayers;

                function moveFeatureLayer(layer:FeatureLayer):void
                {
                    currentFeatureLayerIndex = featureLayers.indexOf(layer);
                    var newFeatureLayerIndex:Number = newLayerIds.length - index - 1;
                    if (newFeatureLayerIndex < currentFeatureLayerIndex)
                    {
                        for (i = currentFeatureLayerIndex; newFeatureLayerIndex <= i; i--)
                        {
                            if (i == newFeatureLayerIndex)
                            {
                                featureLayers[newFeatureLayerIndex] = layer;
                            }
                            else
                            {
                                featureLayers[i] = featureLayers[i - 1];
                            }
                        }
                    }
                    else
                    {
                        for (i = currentFeatureLayerIndex; i <= newFeatureLayerIndex; i++)
                        {
                            if (i == newFeatureLayerIndex)
                            {
                                featureLayers[newFeatureLayerIndex] = layer;
                            }
                            else
                            {
                                featureLayers[i] = featureLayers[i + 1];
                            }
                        }
                    }
                }

                function moveFeatureLayerToTheBottom(layer:FeatureLayer):void
                {
                    currentFeatureLayerIndex = featureLayers.indexOf(layer);
                    for (i = currentFeatureLayerIndex; i < featureLayers.length; i++)
                    {
                        if (i == featureLayers.length - 1)
                        {
                            featureLayers[featureLayers.length - 1] = layer;
                        }
                        else
                        {
                            featureLayers[i] = featureLayers[i + 1];
                        }
                    }
                }
            }

            private function getNewLayerIds(layerIds:Array):Array
            {
                var result:Array = [];
                for (var i:int = 0; i < layerIds.length; i++)
                {
                    var layer:Layer = ArrayCollection(map.layers).getItemAt(i) as Layer;
                    if (layer.name.indexOf("hiddenLayer_") != -1 || (layer is GraphicsLayer && !(layer is FeatureLayer)))
                    {
                        continue
                    }
                    result.push(layerIds[i]);
                }
                return result;
            }

            private function storeInfoWindowRenderer():void
            {
                for each (var layer:Layer in map.layers)
                {
                    if (layer is ArcGISDynamicMapServiceLayer && ArcGISDynamicMapServiceLayer(layer).layerInfoWindowRenderers)
                    {
                        dictionary[layer] = ArcGISDynamicMapServiceLayer(layer).layerInfoWindowRenderers;
                        ArcGISDynamicMapServiceLayer(layer).layerInfoWindowRenderers = null; // set it to null, as widget overtakes now
                    }
                    else if (layer is ArcGISTiledMapServiceLayer && ArcGISTiledMapServiceLayer(layer).layerInfoWindowRenderers)
                    {
                        dictionary[layer] = ArcGISTiledMapServiceLayer(layer).layerInfoWindowRenderers;
                        ArcGISTiledMapServiceLayer(layer).layerInfoWindowRenderers = null; // set it to null, as widget overtakes now
                    }
                    else if (layer is GraphicsLayer && GraphicsLayer(layer).infoWindowRenderer)
                    {
                        dictionary[layer] = GraphicsLayer(layer).infoWindowRenderer;
                        GraphicsLayer(layer).infoWindowRenderer = null; // set it to null, as widget overtakes now
                    }
                }
            }

            private function isLayerPartOfExcludeLayers(layerName:String):Boolean
            {
                var result:Boolean;

                // loop through all the excludeLayers
                for (var n:int = 0; n < excludeLayers.length; )
                {
                    if (layerName == excludeLayers[n])
                    {
                        result = true;
                        break;
                    }
                    else
                    {
                        n++;
                    }
                }

                return result;
            }

            private function isFeatureLayerPartOfOpList(featureLayerURL:String, gdbVersion:String):Boolean
            {
                var result:Boolean;

                // loop through all the map layers
                for each (var layerObj:Object in configData.opLayers)
                {
                    var layer:Layer = layerObj.layer;
                    if (layer is FeatureLayer
                        && FeatureLayer(layer).url == featureLayerURL
                        && FeatureLayer(layer).gdbVersion == gdbVersion)
                    {
                        result = true;
                        break;
                    }
                }

                return result;
            }

            private function getFeatureLayerFromMap(featureLayerURL:String, gdbVersion:String):FeatureLayer
            {
                var result:FeatureLayer;

                // loop through all the map layers
                for (var n:int = 0; n < mapLayers.length; )
                {
                    if (mapLayers.getItemAt(n) is FeatureLayer
                        && FeatureLayer(mapLayers.getItemAt(n)).url == featureLayerURL
                        && FeatureLayer(mapLayers.getItemAt(n)).gdbVersion == gdbVersion)
                    {
                        result = mapLayers.getItemAt(n) as FeatureLayer;
                        break;
                    }
                    else
                    {
                        n++;
                    }
                }

                return result;
            }

            private function visibleLayersChange(event:Event = null):void
            {
                var dynamicMapServiceLayer:ArcGISDynamicMapServiceLayer = ArcGISDynamicMapServiceLayer(event.target);
                if (dynamicMapServiceLayer.visibleLayers)
                {
                    dynamicMapServiceLayer.visibleLayers.removeEventListener(CollectionEvent.COLLECTION_CHANGE, visibleLayersChangeHandler);
                    dynamicMapServiceLayer.visibleLayers.addEventListener(CollectionEvent.COLLECTION_CHANGE, visibleLayersChangeHandler);
                }
                if (dynamicMapServiceLayer.visible)
                {
                    updateFeatureLayersVisibility(dynamicMapServiceLayer, dynamicMapServiceLayer.visibleLayers ? false : true);
                }
            }

            private function visibleLayersChangeHandler(event:CollectionEvent):void
            {
                const mapLayers:ArrayCollection = ArrayCollection(map.layers);
                for (var i:int = 0; i < mapLayers.length; )
                {
                    if (mapLayers.getItemAt(i) is ArcGISDynamicMapServiceLayer &&
                        ArcGISDynamicMapServiceLayer(mapLayers.getItemAt(i)).visible &&
                        ArcGISDynamicMapServiceLayer(mapLayers.getItemAt(i)).visibleLayers === event.target)
                    {
                        updateFeatureLayersVisibility(ArcGISDynamicMapServiceLayer(mapLayers.getItemAt(i)));
                        break;
                    }
                    else
                    {
                        i++;
                    }
                }
            }

            private function layer_isInScaleRangeChangeHandler(event:LayerEvent):void
            {
                updateFeatureLayersVisibility(ArcGISDynamicMapServiceLayer(event.target));
            }

            private function layer_hideShowHandler(event:FlexEvent):void
            {
                updateFeatureLayersVisibility(ArcGISDynamicMapServiceLayer(event.target));
            }

            private function updateFeatureLayersVisibility(layer:ArcGISDynamicMapServiceLayer, goBackToDefaultVisibility:Boolean = false):void
            {
                for each (var featureLayer:FeatureLayer in featureLayers)
                {
                    if (featureLayer.name.indexOf("hiddenLayer_") != -1 && featureLayerToDynamicMapService[featureLayer] === layer) // layers from a map service
                    {
                        var featureLayerId:String = featureLayer.url.substring(featureLayer.url.lastIndexOf("/") + 1, featureLayer.url.length);
                        featureLayer.visible = layer.visible ? isFeatureLayerVisible(featureLayerId, layer, goBackToDefaultVisibility) : false;
                    }
                }
            }

            private function isFeatureLayerVisible(layerId:String, dynamicMapServiceLayer:ArcGISDynamicMapServiceLayer, checkDefaultVisibility:Boolean = false):Boolean
            {
                var result:Boolean;

                if (!checkDefaultVisibility && dynamicMapServiceLayer.visibleLayers)
                {
                    var actualVisibleLayers:Array = getActualVisibleLayers(dynamicMapServiceLayer.visibleLayers.toArray(), dynamicMapServiceLayer.layerInfos);
                    result = actualVisibleLayers.indexOf(Number(layerId)) != -1;
                }
                else
                {
                    var layerInfos:Array = dynamicMapServiceLayer.layerInfos;
                    if (layerInfos)
                    {
                        for (var i:int = 0; i < layerInfos.length; )
                        {
                            if (layerInfos[i].layerId == layerId)
                            {
                                if (layerInfos[i].parentLayerId != -1)
                                {
                                    // find the parent and check its default visibility
                                    var parentLayerInfo:LayerInfo = findLayerById(layerInfos[i].parentLayerId, layerInfos);
                                    result = parentLayerInfo.defaultVisibility;
                                }
                                else
                                {
                                    result = layerInfos[i].defaultVisibility;
                                }
                                break;
                            }
                            else
                            {
                                i++;
                            }
                        }
                    }
                }

                return result;
            }

            private function getActualVisibleLayers(layerIds:Array, layerInfos:Array):Array
            {
                var result:Array = [];

                layerIds = layerIds ? layerIds.concat() : null;
                var layerInfo:LayerInfo;
                var layerIdIndex:int;

                if (layerIds)
                {
                    // replace group layers with their sub layers
                    for each (layerInfo in layerInfos)
                    {
                        layerIdIndex = layerIds.indexOf(layerInfo.layerId);
                        if (layerInfo.subLayerIds && layerIdIndex != -1)
                        {
                            layerIds.splice(layerIdIndex, 1); // remove the group layer id
                            for each (var subLayerId:Number in layerInfo.subLayerIds)
                            {
                                layerIds.push(subLayerId); // add subLayerId
                            }
                        }
                    }

                    for each (layerInfo in layerInfos.reverse())
                    {
                        if (layerIds.indexOf(layerInfo.layerId) != -1 && layerIds.indexOf(layerInfo.parentLayerId) == -1 && layerInfo.parentLayerId != -1)
                        {
                            layerIds.push(layerInfo.parentLayerId);
                        }
                    }

                    result = layerIds;
                }

                return result;
            }

            private function findLayerById(id:Number, layerInfos:Array):LayerInfo
            {
                for each (var layerInfo:LayerInfo in layerInfos)
                {
                    if (id == layerInfo.layerId)
                    {
                        return layerInfo;
                    }
                }
                return null;
            }

            private function featureLayer_hideShowHandler(event:FlexEvent):void
            {
                var featureLayer:FeatureLayer = event.target as FeatureLayer;
                var featureLayerId:Number = Number(featureLayer.url.substring(featureLayer.url.lastIndexOf("/") + 1, featureLayer.url.length));
                var dynamicMapServiceLayer:ArcGISDynamicMapServiceLayer = featureLayerToDynamicMapService[featureLayer];
                if (featureLayer.visible)
                {
                    dynamicMapServiceLayer.visible = true;
                    if (dynamicMapServiceLayer.visibleLayers)
                    {
                        dynamicMapServiceLayer.visibleLayers.addItem(featureLayerId);
                    }
                }
                else
                {
                    if (dynamicMapServiceLayer.visibleLayers && dynamicMapServiceLayer.visibleLayers.getItemIndex(featureLayerId) != -1)
                    {
                        dynamicMapServiceLayer.visibleLayers.removeItemAt(dynamicMapServiceLayer.visibleLayers.getItemIndex(featureLayerId));
                    }
                }
            }

            private function atleastOneFeatureLayerHasCreateCapability(featureLayers:Array):Boolean
            {
                var result:Boolean;
                for each (var featureLayer:FeatureLayer in featureLayers)
                {
                    if (isCreateAllowed(featureLayer))
                    {
                        result = true;
                        break;
                    }
                }
                return result;
            }

            private function isCreateAllowed(featureLayer:FeatureLayer):Boolean
            {
                var result:Boolean;

                if (featureLayer.layerDetails is FeatureLayerDetails)
                {
                    result = (featureLayer.layerDetails as FeatureLayerDetails).isCreateAllowed;
                }
                else if (featureLayer.tableDetails is FeatureTableDetails)
                {
                    result = (featureLayer.tableDetails as FeatureTableDetails).isCreateAllowed;
                }

                return result;
            }

            private function deactivateEditor():void
            {
                map.infoWindow.hide();
                editor.templatePicker.clearSelection();

                editor.featureLayers = null;
                editor.map = null;
                editor.drawTool.deactivate();
                editor.editTool.deactivate();
            }

            private function featureLayer_selectionComplete(event:FeatureLayerEvent):void
            {
                for each (var field:Field in event.target.layerDetails.fields)
                {
                    if (field.type == Field.TYPE_DATE)
                    {
                        for each (var feature:Graphic in event.features)
                        {
                            var date:Date = new Date(feature.attributes[field.name]);
                            if (date.milliseconds == 999)
                            {
                                date.milliseconds++; //Add 1ms to date values ending in 999 to workaround REST date bug
                                feature.attributes[field.name] = date.time;
                            }
                        }
                    }
                }
            }

            private function infoWindowCloseHandler(event:Event):void
            {
                map.infoWindow.content = editor.attributeInspector;
                if (attachmentInspector)
                {
                    attachmentInspector.clear();
                }
                if (relationshipInspector)
                {
                    relationshipInspector.clear();
                }
            }

            private function attributeGroupClickedHandler(event:Event):void
            {
                map.infoWindow.content = editor.attributeInspector;
            }

            private function attachmentGroupClickedHandler(event:Event):void
            {
                map.infoWindow.content = attachmentInspector;

                // queues an operation(showAttachments) to be performed for the next screen refresh, rather than in the current update.
                // Without the callLater() method, you might try to access a property of a component
                // that is not yet available.
                callLater(showAttachments);

                function showAttachments():void
                {
                    attachmentInspector.showAttachments(editor.attributeInspector.activeFeature, editor.attributeInspector.activeFeature.graphicsLayer as FeatureLayer);
                }
            }

            private function relatedRecordsGroupClickedHandler(event:Event):void
            {
                map.infoWindow.content = relationshipInspector;
                relationshipInspector.graphic = editor.attributeInspector.activeFeature;
            }

            private function attachmentInspector_initializeHandler(event:FlexEvent):void
            {
                super.initializationComplete();
                attachmentInspector.addEventListener(AttachmentMouseEvent.ATTACHMENT_DOUBLE_CLICK, attachmentDoubleClickHandler);
            }

            private function attachmentDoubleClickHandler(event:AttachmentMouseEvent):void
            {
                navigateToURL(new URLRequest(event.attachmentInfo.url));
            }

            private function attributeGroup_clickHandler(event:MouseEvent):void
            {
                map.infoWindow.content = editor.attributeInspector;
            }

            private function attributeInspector_showFeatureHandler(event:AttributeInspectorEvent):void
            {
                attachmentInspector.addEnabled = editor.attributeInspector.updateEnabled;
                attachmentInspector.deleteEnabled = editor.attributeInspector.deleteButtonVisible;
                const featureLayer:FeatureLayer = event.featureLayer;
                var settingsKey:String = featureLayer.name;
                if (featureLayer.name.indexOf("hiddenLayer_") != -1)
                {
                    settingsKey = hiddenFeatureLayerToSettingsName[featureLayer];
                    if (!settingsKey)
                    {
                        settingsKey = featureLayerToDynamicMapService[featureLayer].name +
                            "/" + featureLayer.url.substring(featureLayer.url.lastIndexOf("/") + 1, featureLayer.url.length);
                        hiddenFeatureLayerToSettingsName[featureLayer] = settingsKey;
                    }
                }
                var settingsObject:Object = layerToSettings[settingsKey];
                if (settingsObject)
                {
                    var outFields:Array = settingsObject.outFields as Array;
                    if (outFields && outFields.length)
                    {
                        var attributeInspectorFieldInspectors:Array = [];
                        var fieldInspector:FieldInspector;
                        for each (var fieldObject:Object in outFields)
                        {
                            fieldInspector = new FieldInspector;
                            fieldInspector.featureLayer = featureLayer;
                            fieldInspector.visible = true;
                            fieldInspector.fieldName = fieldObject.name;
                            fieldInspector.label = fieldObject.alias;
                            fieldInspector.toolTip = fieldObject.tooltip;
                            if (isDateField(fieldObject.name, featureLayer) &&
                                (fieldObject.dateFormat != null || fieldObject.useUTC != null))
                            {
                                var calendarFieldFactory:ClassFactory = new ClassFactory(CalendarField);
                                calendarFieldFactory.properties = {};
                                if (fieldObject.dateFormat != null)
                                {
                                    calendarFieldFactory.properties.dateFormat = fieldObject.dateFormat;
                                }
                                if (fieldObject.useUTC != null)
                                {
                                    calendarFieldFactory.properties.useUTC = fieldObject.useUTC;
                                }
                                fieldInspector.editor = calendarFieldFactory;
                            }
                            if (fieldObject.required != null)
                            {
                                fieldInspector.required = fieldObject.required;
                            }
                            attributeInspectorFieldInspectors.push(fieldInspector);
                        }
                        for each (var field:Field in featureLayer.layerDetails.fields)
                        {
                            if (outFields.indexOf(field.name) == -1)
                            {
                                fieldInspector = new FieldInspector;
                                fieldInspector.featureLayer = featureLayer;
                                fieldInspector.visible = false;
                                fieldInspector.fieldName = field.name;

                                attributeInspectorFieldInspectors.push(fieldInspector);
                            }
                        }
                        editor.attributeInspector.fieldInspectors = attributeInspectorFieldInspectors;
                        editor.attributeInspector.formFieldsOrder = AttributeInspector.FIELD_INSPECTOR_ORDER;
                    }
                    else
                    {
                        var formFieldsOrder:String = settingsObject.formFieldsOrder;
                        if (formFieldsOrder)
                        {
                            editor.attributeInspector.formFieldsOrder = formFieldsOrder;
                        }
                    }
                    var singleToMultilineThreshold:Number = settingsObject.singleToMultilineThreshold;
                    if (singleToMultilineThreshold && !isNaN(singleToMultilineThreshold))
                    {
                        editor.attributeInspector.singleToMultilineThreshold = singleToMultilineThreshold;
                    }
                    var showObjectID:String = settingsObject.showObjectID;
                    if (showObjectID)
                    {
                        editor.attributeInspector.showObjectID = showObjectID == "true";
                    }
                    var showGlobalID:String = settingsObject.showGlobalID;
                    if (showGlobalID)
                    {
                        editor.attributeInspector.showGlobalID = showGlobalID == "true";
                    }
                }
            }

            private function isDateField(fieldName:String, featureLayer:FeatureLayer):Boolean
            {
                var result:Boolean;

                var fields:Array = featureLayer.layerDetails.fields;
                if (fields)
                {
                    for each (var field:Field in fields)
                    {
                        if (field.name == fieldName && field.type == Field.TYPE_DATE)
                        {
                            result = true;
                            break;
                        }
                    }
                }

                return result;
            }

            private function widgetClosedHandler(event:Event):void
            {
                disablePanZoomNavigationWidget = false;
                addSharedData("Edit_Widget", new ArrayCollection([ disablePanZoomNavigationWidget ])); // to be able to enable pan/zoomin/zoomout

                lastState = "closed";

                // clear feature layer selection
                for each (var featureLayer:FeatureLayer in featureLayers)
                {
                    if (featureLayer.selectedFeatures.length > 0)
                    {
                        featureLayer.clearSelection();
                    }
                    if (featureLayer.name.indexOf("hiddenLayer_") != -1)
                    {
                        map.removeLayer(featureLayer);
                    }
                }
                // assign back the renderer info
                for (var layer:Object in dictionary)
                {
                    if (layer is ArcGISDynamicMapServiceLayer)
                    {
                        ArcGISDynamicMapServiceLayer(layer).layerInfoWindowRenderers = dictionary[layer];
                    }
                    else if (layer is ArcGISTiledMapServiceLayer)
                    {
                        ArcGISTiledMapServiceLayer(layer).layerInfoWindowRenderers = dictionary[layer];
                    }
                    if (layer is GraphicsLayer)
                    {
                        GraphicsLayer(layer).infoWindowRenderer = dictionary[layer];
                    }
                }
                deactivateEditor();
            }

            private function widgetOpenedHandler(event:Event):void
            {
                disablePanZoomNavigationWidget = true;
                addSharedData("Edit_Widget", new ArrayCollection([ disablePanZoomNavigationWidget ])); // to be able to disable pan/zoomin/zoomout

                // hide the infowindow if already there from other widget
                if (lastState == "closed") // reset only if the widget was opened after being closed
                {
                    mapLayers = map.layers as ArrayCollection;
                    arrLayers = getLayers(mapLayers); // get all the layers on map except basemap layers;
                    populateEditor(arrLayers);
                }
            }

            private function widgetMinimizedHandler(event:Event):void
            {
                lastState = "minimized";
            }
        ]]>
    </fx:Script>

    <fx:Declarations>
        <esri:GeometryService id="geometryService" url="http://tasks.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer"/>
        <esri:CreateOptions id="createOptions"/>
        <esri:AttachmentInspector id="attachmentInspector"
                                  width="{Math.max(map.infoWindowContent.width, 300)}" height="{Math.max(map.infoWindowContent.height, 300)}"
                                  infoWindowLabel="{attachmentsLabel}"
                                  initialize="attachmentInspector_initializeHandler(event)"
                                  skinClass="widgets.Edit.EditWidgetAttachmentInspectorSkin"/>
        <esri:RelationshipInspector id="relationshipInspector"
                                    width="{Math.max(map.infoWindowContent.width, 300)}" height="{Math.max(map.infoWindowContent.height, 300)}"
                                    editEnabled="true"
                                    infoWindowLabel="{relatedRecordsLabel}"
                                    skinClass="widgets.Edit.EditWidgetRelationshipInspectorSkin"/>
    </fx:Declarations>

    <viewer:WidgetTemplate id="wTemplate"
                           closed="widgetClosedHandler(event)"
                           minimized="widgetMinimizedHandler(event)"
                           open="widgetOpenedHandler(event)">
        <viewer:layout>
            <s:VerticalLayout paddingLeft="5" paddingTop="10"/>
        </viewer:layout>
        <s:Label id="selectTemplateLabel"
                 width="100%"
                 includeInLayout="false"
                 text="{getDefaultString('selectTemplateText')}"
                 visible="false"/>
        <mx:Spacer/>
        <s:Label id="noLayers"
                 width="100%"
                 includeInLayout="false"
                 text="{noEditableLayersText}"
                 visible="false"/>
        <esri:Editor id="editor"
                     width="100%" height="100%"
                     geometryService="{geometryService}"/>
    </viewer:WidgetTemplate>
</viewer:BaseWidget>
