<?xml version="1.0" encoding="utf-8"?>
<!--
     ////////////////////////////////////////////////////////////////////////////////
     //
     // Copyright (c) 2010 ESRI
     //
     // All rights reserved under the copyright laws of the United States.
     // You may freely redistribute and use this software, with or
     // without modification, provided you include the original copyright
     // and use restrictions.  See use restrictions in the file:
     // <install location>/License.txt
     //
     ////////////////////////////////////////////////////////////////////////////////
-->
<s:SkinnableContainer xmlns:fx="http://ns.adobe.com/mxml/2009"
                      xmlns:s="library://ns.adobe.com/flex/spark"
                      xmlns:mx="library://ns.adobe.com/flex/mx"
                      width="100%" height="100%"
                      creationComplete="init()"
                      skinClass="com.esri.viewer.skins.MapManagerSkin">

    <fx:Script>
        <![CDATA[
            import com.esri.ags.Graphic;
            import com.esri.ags.Map;
            import com.esri.ags.SpatialReference;
            import com.esri.ags.events.DrawEvent;
            import com.esri.ags.events.MapEvent;
            import com.esri.ags.geometry.Extent;
            import com.esri.ags.layers.ArcGISDynamicMapServiceLayer;
            import com.esri.ags.layers.ArcGISImageServiceLayer;
            import com.esri.ags.layers.ArcGISTiledMapServiceLayer;
            import com.esri.ags.layers.ArcIMSMapServiceLayer;
            import com.esri.ags.layers.FeatureLayer;
            import com.esri.ags.layers.Layer;
            import com.esri.ags.layers.WMSLayer;
            import com.esri.ags.layers.supportClasses.StaticLayer_m_esriLogo;
            import com.esri.ags.symbols.SimpleFillSymbol;
            import com.esri.ags.symbols.SimpleLineSymbol;
            import com.esri.ags.symbols.SimpleMarkerSymbol;
            import com.esri.ags.symbols.Symbol;
            import com.esri.ags.symbols.TextSymbol;
            import com.esri.ags.tools.DrawTool;
            import com.esri.ags.tools.NavigationTool;
            import com.esri.ags.virtualearth.VETiledLayer;
            import com.esri.viewer.AppEvent;
            import com.esri.viewer.ConfigData;
            import com.esri.viewer.IBaseWidget;
            import com.esri.viewer.IInfowindowTemplate;
            import com.esri.viewer.ViewerContainer;
            import com.esri.viewer.components.InfoPopup;

            import mx.collections.ArrayCollection;
            import mx.collections.ArrayList;
            import mx.containers.Canvas;
            import mx.controls.Alert;
            import mx.events.CloseEvent;
            import mx.events.FlexEvent;
            import mx.managers.CursorManagerPriority;
            import mx.utils.StringUtil;

            import spark.components.Group;

            [Embed(source="../../../../assets/images/cross_cursor.png")]
            private var _crossCursor:Class;
            private var _cursorID:int = -1;

            /* skin section */
            [SkinPart(required="false")]
            public var managerView:Group;

            [SkinPart(required="false")]
            public var map:Map;

            [Bindable]
            public var mapLeft:Number = 0;

            [Bindable]
            public var mapRight:Number = 0;

            [Bindable]
            public var mapTop:Number = 0;

            [Bindable]
            public var mapBottom:Number = 0;

            [SkinState("decorated")]
            [SkinState("resized")]
            [SinkState("normal")]

            private var configData:ConfigData;

            private var defaultstatus:String;

            //[SkinPart(required="false")]
            private var infoPopup:InfoPopup;

            private var navTool:NavigationTool;

            private var navigationTool:String;

            private var navigationStatus:String;

            private var drawTool:DrawTool;

            private var drawEndFunction:Function;

            private var fullExtent:Extent;

            private var _mapManagerState:String = "resized";

            private var optLayerTable:Array = new Array()

            //init
            private function init():void
            {
                ViewerContainer.addEventListener(AppEvent.CONFIG_LOADED, config);
                ViewerContainer.addEventListener(AppEvent.SET_MAP_NAVIGATION, changeNavigationbyMenu);
                ViewerContainer.addEventListener(AppEvent.BASEMAP_SWITCH, basemapMenuClicked);
                ViewerContainer.addEventListener(AppEvent.SET_MAP_ACTION, enableMapAction);
                ViewerContainer.addEventListener(AppEvent.SHOW_INFOWINDOW, widgetShowInfo);
                ViewerContainer.addEventListener(AppEvent.MAP_RESIZE, resizeMap);
                ViewerContainer.addEventListener(AppEvent.DATA_OPT_LAYERS, sendOptlayers);
                ViewerContainer.addEventListener(AppEvent.MAP_LAYER_VISIBLE, changeLayerVisible);
            }

            protected override function partAdded(partName:String, instance:Object):void
            {
                super.partAdded(partName, instance);
                if (instance == map)
                {
                    var cssStyleDeclaration:CSSStyleDeclaration = styleManager.getStyleDeclaration("com.esri.ags.components.supportClasses.InfoContainer")
                    cssStyleDeclaration.setStyle("backgroundColor", getStyle('contentBackgroundColor'));
                    styleManager.setStyleDeclaration("com.esri.ags.components.supportClasses.InfoContainer", cssStyleDeclaration, true);
                    map.addEventListener(MapEvent.LOAD, mapLoadComplete);
                }
            }

            private function setViewerVersion():void
            {
                var contextMenuText:String = nlsString("contextMenuText");
                var aboutText:String = nlsString("aboutText");
                var menuItem:ContextMenuItem = new ContextMenuItem(contextMenuText, true, true);
                menuItem.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, function(event:ContextMenuEvent):void
                {
                    // save normal labels
                    var buttonWidth:Number = Alert.buttonWidth;
                    var yesLabel:String = Alert.yesLabel;
                    var noLabel:String = Alert.noLabel;
                    // change labels
                    Alert.buttonWidth = 100;
                    Alert.yesLabel = nlsString("aboutLearnMoreBtn");
                    Alert.noLabel = nlsString("aboutCloseBtn");
                    Alert.show(aboutText, contextMenuText, Alert.YES | Alert.NO, null, function(event:CloseEvent):void
                    {
                        if (event.detail == Alert.YES)
                        {
                            navigateToURL(new URLRequest("http://help.arcgis.com/en/webapps/flexviewer/"));
                        }
                    }, StaticLayer_m_esriLogo, Alert.NO);
                    // restore labels to normal
                    Alert.buttonWidth = buttonWidth;
                    Alert.yesLabel = yesLabel;
                    Alert.noLabel = noLabel;
                });
                if (map.contextMenu)
                {
                    // call contextMenu dynamically so this will compile in AIR
                    if (map.contextMenu["customItems"] is Array)
                    {
                        (map.contextMenu["customItems"] as Array).push(menuItem);
                    }
                    else if (map.contextMenu["addItem"])
                    {
                        map.contextMenu["addItem"](menuItem);
                    }
                }
            }

            //config
            //TODO: Factory or builder pattern need to be used for extendability
            private function config(event:AppEvent):void
            {
                configData = event.data as ConfigData;

                ViewerContainer.dispatchEvent(new AppEvent(AppEvent.MAP_LOADED, map));

                var infoContainer:Canvas = new Canvas();
                infoContainer.setStyle("borderSkin", null);

                /* Adding this two lines removes the container that displays below the header controller in graphical theme
                   but increases CPU usage. Need to convert see if this is needed. if yes, then could be replaced by Group

                   infoContainer.x = -100
                   infoContainer.y = -100
                 */
                infoContainer.percentWidth = 100;
                infoContainer.percentHeight = 100;
                infoContainer.horizontalScrollPolicy = "off";
                infoContainer.verticalScrollPolicy = "off";
                managerView.addElement(infoContainer);

                infoPopup = new InfoPopup();
                infoPopup.map = map;
                infoContainer.addChild(infoPopup);

                navTool = new NavigationTool();
                navTool.map = map;

                drawTool = new DrawTool();
                drawTool.map = map;
                drawTool.addEventListener(DrawEvent.DRAW_END, onDrawEnd);

                configMapAttributes();

                configBasemaps();
                configOptLayers();
                configReferenceBasemaps();

                setViewerVersion();
            }

            private function configMapAttributes():void
            {
                var ref:SpatialReference;
                var iextent:Extent;

                for (var i:int = 0; i < configData.mapAttrs.length; i++)
                {
                    var id:String = configData.mapAttrs[i].id;

                    if (id == "full")
                    {
                        var ext:String = configData.mapAttrs[i].extent;
                        var extArray:Array = ext.split(" ");
                        var extent:Extent = new Extent(Number(extArray[0]), Number(extArray[1]), Number(extArray[2]), Number(extArray[3]));
                        fullExtent = extent;
                    }
                    else if (id == "initial")
                    {
                        var iext:String = configData.mapAttrs[i].extent;
                        var iextArray:Array = iext.split(" ");
                        iextent = new Extent(Number(iextArray[0]), Number(iextArray[1]), Number(iextArray[2]), Number(iextArray[3]));
                    }
                    else if (id == "map")
                    {
                        var mapAttr:Object = configData.mapAttrs[i];
                        if (mapAttr.left || mapAttr.right || mapAttr.top || mapAttr.bottom)
                        {
                            this._mapManagerState = "decorated";
                            dispatchEvent(new Event(_mapManagerState));
                            invalidateSkinState();

                            if (mapAttr.left)
                            {
                                this.left = mapAttr.left;
                            }
                            if (mapAttr.right)
                            {
                                this.right = mapAttr.right;
                            }
                            if (mapAttr.top)
                            {
                                this.top = mapAttr.top;
                            }
                            if (mapAttr.bottom)
                            {
                                this.bottom = mapAttr.bottom;
                            }
                        }
                    }
                    else if (id == "spatialref")
                    {
                        var wkid:Number = configData.mapAttrs[i].wkid;
                        var wkt:String = configData.mapAttrs[i].wkt;

                        if (wkid || wkt)
                        {
                            ref = new SpatialReference(wkid, wkt);
                        }

                        configData.mapAttrs[i].refObj = ref;
                    }
                    else if (id == "zoomSlider")
                    {
                        map.zoomSliderVisible = configData.mapAttrs[i].zoomSliderVisible;
                    }
                    else if (id == "scaleBar")
                    {
                        map.scaleBarVisible = configData.mapAttrs[i].scaleBarVisible;
                    }
                    else if (id == "esriLogo")
                    {
                        map.logoVisible = configData.mapAttrs[i].esriLogoVisible;
                    }
                    else if (id == "openHandCursor")
                    {
                        map.openHandCursorVisible = configData.mapAttrs[i].openHandCursorVisible;
                    }
                    else if (id == "lods")
                    {
                        map.lods = configData.mapAttrs[i].lods;
                    }
                }

                if (fullExtent)
                {
                    fullExtent.spatialReference = ref;
                }
                if (iextent)
                {
                    iextent.spatialReference = ref;
                    map.extent = iextent;
                }
            }

            private function configBasemaps():void
            {
                var layers:Array = configData.basemaps;
                for (var i:uint = 0; i < layers.length; i++)
                {
                    if (!layers[i].reference)
                    {
                        addLayerToMap(layers[i], false);
                    }
                }

                if (layers.length > 0)
                {
                    map.addEventListener(MapEvent.LAYER_ADD, layerloadComplete);
                }
            }

            private function configReferenceBasemaps():void
            {
                var layers:Array = configData.basemaps;
                for (var i:uint = 0; i < layers.length; i++)
                {
                    if (layers[i].reference)
                    {
                        addLayerToMap(layers[i], false);
                    }
                }
            }

            private var olayers:Array = [];

            private function configOptLayers():void
            {
                var layers:Array = configData.opLayers;
                if (layers && layers.length > 0)
                {
                    for (var i:uint = 0; i < layers.length; i++)
                    {
                        olayers.push(layers[i]);
                    }
                }

                if (olayers.length > 0)
                {
                    loadNextOptlayer();
                }
            }

            private var lyrIdx:int = 0;

            private function loadNextOptlayer():void
            {
                var lyr:Object = olayers[lyrIdx];
                addLayerToMap(lyr, true);

                if (lyr.infoUrl)
                {
                    var data:Object =
                        {
                            id: lyr.label,
                            url: lyr.infoUrl,
                            config: lyr.infoConfig
                        };

                    ViewerContainer.dispatchEvent(new AppEvent(AppEvent.DATA_CREATE_INFOWIDGET, data, infoReady));
                }
                else
                {
                    // add to the optLayerTable even when not a featureLayer
                    optLayerTable.push(olayers[lyrIdx]);
                    lyrIdx++;

                    if (lyrIdx < olayers.length)
                    {
                        loadNextOptlayer();
                    }
                }
            }

            private function addLayerToMap(layerObject:Object, operationalLayer:Boolean):void
            {
                const alpha:Number = Number(layerObject.alpha);
                const autoRefresh:Number = Number(layerObject.autoRefresh);
                const bandIds:String = layerObject.bandIds;
                const bingMapKey:String = layerObject.key;
                const culture:String = layerObject.culture;
                const definitionExpression:String = layerObject.definitionExpression;
                const displayLevels:String = layerObject.displayLevels;
                const imageFormat:String = layerObject.imageFormat;
                const label:String = layerObject.label;
                const mode:String = layerObject.mode;
                const noData:Number = Number(layerObject.noData);
                const password:String = layerObject.password;
                const proxyUrl:String = configData.proxyUrl;
                const serviceHost:String = layerObject.serviceHost;
                const serviceName:String = layerObject.serviceName;
                const skipGetCapabilities:String = layerObject.skipGetCapabilities;
                const style:String = layerObject.style;
                const token:String = layerObject.token;
                const type:String = layerObject.type;
                const url:String = layerObject.url;
                const useAMF:String = layerObject.useAMF;
                const useMapTime:Boolean = layerObject.useMapTime;
                const useProxy:Boolean = layerObject.useProxy;
                const username:String = layerObject.username;
                const version:String = layerObject.version;
                const visible:Boolean = layerObject.visible;
                const visibleLayers:String = layerObject.visibleLayers;

                var i:int;
                switch (type.toLowerCase())
                {
                    case "tiled":
                    {
                        var tiledLayer:ArcGISTiledMapServiceLayer = new ArcGISTiledMapServiceLayer(url);
                        tiledLayer.alpha = alpha;
                        tiledLayer.id = label;
                        tiledLayer.name = label;
                        tiledLayer.token = token;
                        tiledLayer.visible = visible;
                        if (displayLevels)
                        {
                            tiledLayer.displayLevels = displayLevels.split(",");
                            for (i = 0; i < tiledLayer.displayLevels.length; i++)
                            {
                                tiledLayer.displayLevels[i] = Number(tiledLayer.displayLevels[i]); // convert to Numbers
                            }
                        }
                        if (proxyUrl && useProxy)
                        {
                            tiledLayer.proxyURL = proxyUrl;
                        }
                        if (operationalLayer)
                        {
                            layerObject.layer = tiledLayer;
                        }
                        map.addLayer(tiledLayer);
                        break;
                    }
                    case "dynamic":
                    {
                        var dynLayer:ArcGISDynamicMapServiceLayer = new ArcGISDynamicMapServiceLayer(url);
                        dynLayer.alpha = alpha;
                        dynLayer.id = label;
                        dynLayer.name = label;
                        dynLayer.token = token;
                        dynLayer.visible = visible;
                        dynLayer.useMapTime = useMapTime;
                        if (autoRefresh > 0)
                        {
                            setInterval(dynLayer.refresh, autoRefresh * 1000);
                        }
                        if (imageFormat)
                        {
                            dynLayer.imageFormat = imageFormat;
                        }
                        if (visibleLayers)
                        {
                            var vizLayers:Array = visibleLayers.split(",");
                            for (i = 0; i < vizLayers.length; i++)
                            {
                                vizLayers[i] = Number(vizLayers[i]); // convert to Numbers
                            }
                            dynLayer.visibleLayers = new ArrayCollection(vizLayers);
                        }
                        if (proxyUrl && useProxy)
                        {
                            dynLayer.proxyURL = proxyUrl;
                        }
                        if (operationalLayer)
                        {
                            layerObject.layer = dynLayer;
                        }
                        map.addLayer(dynLayer);
                        break;
                    }
                    case "feature":
                    {
                        var featureLayer:FeatureLayer = new FeatureLayer(url);
                        featureLayer.addEventListener(FlexEvent.HIDE, featureLayer_hideHandler);
                        featureLayer.alpha = alpha;
                        featureLayer.id = label;
                        featureLayer.name = label;
                        featureLayer.outFields = [ '*' ];
                        featureLayer.token = token;
                        featureLayer.visible = visible;
                        featureLayer.useMapTime = useMapTime;
                        if (useAMF)
                        {
                            featureLayer.useAMF = useAMF == "true";
                        }
                        if (mode)
                        {
                            featureLayer.mode = mode;
                        }
                        if (definitionExpression && definitionExpression != "")
                        {
                            featureLayer.definitionExpression = definitionExpression;
                        }
                        if (proxyUrl && useProxy)
                        {
                            featureLayer.proxyURL = proxyUrl;
                        }
                        if (operationalLayer)
                        {
                            layerObject.layer = featureLayer;
                        }
                        map.addLayer(featureLayer);
                        break;
                    }
                    case "bing":
                    {
                        var veTiledLayer:VETiledLayer = new VETiledLayer();
                        veTiledLayer.id = label;
                        veTiledLayer.name = label;
                        veTiledLayer.key = bingMapKey;
                        veTiledLayer.visible = visible;
                        veTiledLayer.alpha = alpha;
                        if (style)
                        {
                            veTiledLayer.mapStyle = style;
                        }
                        if (culture)
                        {
                            veTiledLayer.culture = culture;
                        }
                        if (displayLevels)
                        {
                            veTiledLayer.displayLevels = displayLevels.split(",");
                            for (i = 0; i < veTiledLayer.displayLevels.length; i++)
                            {
                                veTiledLayer.displayLevels[i] = Number(veTiledLayer.displayLevels[i]); // convert to Numbers
                            }
                        }
                        if (operationalLayer)
                        {
                            layerObject.layer = veTiledLayer;
                        }
                        map.addLayer(veTiledLayer);
                        break;
                    }
                    case "image":
                    {
                        var imgLayer:ArcGISImageServiceLayer = new ArcGISImageServiceLayer(url);
                        imgLayer.id = label;
                        imgLayer.name = label;
                        imgLayer.alpha = alpha;
                        imgLayer.token = token;
                        imgLayer.visible = visible;
                        imgLayer.noData = noData;
                        imgLayer.useMapTime = useMapTime;
                        if (imageFormat)
                        {
                            imgLayer.imageFormat = imageFormat;
                        }
                        if (bandIds)
                        {
                            imgLayer.bandIds = bandIds.split(",");
                            for (i = 0; i < imgLayer.bandIds.length; i++)
                            {
                                imgLayer.bandIds[i] = Number(imgLayer.bandIds[i]); // convert to Numbers
                            }
                        }
                        if (proxyUrl && useProxy)
                        {
                            imgLayer.proxyURL = proxyUrl;
                        }
                        if (operationalLayer)
                        {
                            layerObject.layer = imgLayer;
                        }
                        map.addLayer(imgLayer);
                        break;
                    }
                    case "arcims":
                    {
                        var arcimsLayer:ArcIMSMapServiceLayer = new ArcIMSMapServiceLayer();
                        arcimsLayer.alpha = alpha;
                        arcimsLayer.id = label;
                        arcimsLayer.name = label;
                        arcimsLayer.visible = visible;
                        arcimsLayer.serviceHost = serviceHost;
                        arcimsLayer.serviceName = serviceName;
                        if (autoRefresh > 0)
                        {
                            setInterval(arcimsLayer.refresh, autoRefresh * 1000);
                        }
                        if (imageFormat)
                        {
                            arcimsLayer.imageFormat = imageFormat;
                        }
                        if (visibleLayers)
                        {
                            var visLayers:Array = visibleLayers.split(",");
                            arcimsLayer.visibleLayers = new ArrayCollection(visLayers);
                        }
                        if (proxyUrl && useProxy)
                        {
                            arcimsLayer.proxyURL = proxyUrl;
                        }
                        if (username && password)
                        {
                            arcimsLayer.username = username;
                            arcimsLayer.password = password;
                        }
                        if (operationalLayer)
                        {
                            layerObject.layer = arcimsLayer;
                        }
                        map.addLayer(arcimsLayer);
                        break;
                    }
                    case "wms":
                    {
                        var wmsLayer:WMSLayer = new WMSLayer(url);
                        wmsLayer.alpha = alpha;
                        wmsLayer.id = label;
                        wmsLayer.name = label;
                        wmsLayer.visible = visible;
                        if (autoRefresh > 0)
                        {
                            setInterval(wmsLayer.refresh, autoRefresh * 1000);
                        }
                        if (imageFormat)
                        {
                            wmsLayer.imageFormat = imageFormat;
                        }
                        if (visibleLayers)
                        {
                            var wmsVisLayers:Array = visibleLayers.split(",");
                            wmsLayer.visibleLayers = new ArrayList(wmsVisLayers);
                        }
                        if (proxyUrl && useProxy)
                        {
                            wmsLayer.proxyURL = proxyUrl;
                        }
                        if (skipGetCapabilities)
                        {
                            wmsLayer.skipGetCapabilities = skipGetCapabilities == "true";
                        }
                        if (username && password)
                        {
                            wmsLayer.username = username;
                            wmsLayer.password = password;
                        }
                        if (version)
                        {
                            wmsLayer.version = version;
                        }
                        if (operationalLayer)
                        {
                            layerObject.layer = wmsLayer;
                        }
                        map.addLayer(wmsLayer);
                        break;
                    }
                    default:
                    {
                        Alert.show(StringUtil.substitute(nlsString('incorrectLayerTypeText'), "'" + type + "'"));
                        break;
                    }
                }
            }

            private function featureLayer_hideHandler(event:FlexEvent):void
            {
                const featureLayer:FeatureLayer = event.target as FeatureLayer;
                const graphic:Graphic = map.infoWindow.contentOwner as Graphic;
                if (map.infoWindow.visible && graphic && graphic.graphicsLayer === featureLayer)
                {
                    map.infoWindow.hide();
                }
            }

            private var infoTemplate:IInfowindowTemplate;

            private var infoRender:ClassFactory;

            private function infoReady(event:AppEvent):void
            {
                var id:String = event.data.id as String;
                if (id == olayers[lyrIdx].label)
                {
                    infoTemplate = event.data.infoWidget;
                    var biWidget:IBaseWidget = infoTemplate as IBaseWidget;
                    var infoConfigXML:XML = biWidget.configXML;
                    infoRender = new ClassFactory(infoTemplate.infoClass);
                    infoRender.properties = { infoConfig: infoConfigXML, map: map };

                    olayers[lyrIdx].layer.infoWindowRenderer = infoRender;
                }

                optLayerTable.push(olayers[lyrIdx]);
                lyrIdx++;

                if (lyrIdx < olayers.length)
                {
                    loadNextOptlayer();
                }
            }

            private function sendOptlayers(event:AppEvent):void
            {
                var callback:Function = event.callback as Function;
                callback(new AppEvent(AppEvent.DATA_OPT_LAYERS, this.optLayerTable));
            }

            private function layerloadComplete(event:MapEvent):void
            {
                ViewerContainer.dispatchEvent(new AppEvent(AppEvent.LAYER_LOADED));
            }

            override protected function getCurrentSkinState():String
            {
                return _mapManagerState;
            }

            //map load complete
            private function mapLoadComplete(event:MapEvent):void
            {
                // ViewerContainer.dispatchEvent(new AppEvent(AppEvent.LAYER_LOADED));
            }

            //nav tool clicked
            private function changeNavigationbyWidget(event:AppEvent):void
            {
                navigationTool = event.data ? event.data.tool : null;
                navigationStatus = event.data ? event.data.status : null;

                changeNavigation(navigationTool, navigationStatus);
            }

            private function changeNavigationbyMenu(event:AppEvent):void
            {
                navigationTool = event.data ? event.data.tool : null;
                navigationStatus = event.data ? event.data.status : null;

                changeNavigation(navigationTool, navigationStatus);
            }

            private function changeNavigation(tool:String, status:String):void
            {
                map.removeEventListener(MouseEvent.ROLL_OVER, map_rollOverHandler);
                map.removeEventListener(MouseEvent.ROLL_OUT, map_rollOutHandler);
                if (tool)
                {
                    switch (tool)
                    {
                        case NavigationTool.ZOOM_IN:
                        {
                            // custom cursor
                            map.addEventListener(MouseEvent.ROLL_OVER, map_rollOverHandler);
                            map.addEventListener(MouseEvent.ROLL_OUT, map_rollOutHandler);

                            drawTool.deactivate();
                            navTool.deactivate();
                            navTool.activate(tool);
                            ViewerContainer.setStatus(status);
                            break;
                        }
                        case NavigationTool.ZOOM_OUT:
                        {
                            // custom cursor
                            map.addEventListener(MouseEvent.ROLL_OVER, map_rollOverHandler);
                            map.addEventListener(MouseEvent.ROLL_OUT, map_rollOutHandler);

                            drawTool.deactivate();
                            navTool.deactivate();
                            navTool.activate(tool);
                            ViewerContainer.setStatus(status);
                            break;
                        }
                        case ViewerContainer.NAVIGATION_ZOOM_FULL:
                        {
                            if (fullExtent)
                            {
                                map.extent = fullExtent;
                            }
                            else
                            {
                                navTool.zoomToFullExtent();
                            }
                            ViewerContainer.setStatus(null);
                            break;
                        }
                        case ViewerContainer.NAVIGATION_ZOOM_PREVIOUS:
                        {
                            navTool.zoomToPrevExtent();
                            ViewerContainer.setStatus(null);
                            break;
                        }
                        case ViewerContainer.NAVIGATION_ZOOM_NEXT:
                        {
                            navTool.zoomToNextExtent();
                            ViewerContainer.setStatus(null);
                            break;
                        }
                        case NavigationTool.PAN:
                        {
                            drawTool.deactivate();
                            navTool.activate(tool);
                            navTool.deactivate();
                            ViewerContainer.setStatus(status);
                            break;
                        }
                        default:
                        {
                            drawTool.deactivate();
                            navTool.activate(NavigationTool.PAN);
                            navTool.deactivate();
                            ViewerContainer.setStatus(defaultstatus);
                            break;
                        }
                    }
                }
            }

            private function map_rollOverHandler(event:MouseEvent):void
            {
                map.cursorManager.setCursor(_crossCursor, CursorManagerPriority.MEDIUM, -8, -8);
            }

            private function map_rollOutHandler(event:MouseEvent):void
            {
                map.cursorManager.removeAllCursors();
            }

            //draw tool clicked
            private function enableMapAction(event:AppEvent):void
            {
                var data:Object = event.data;
                var tool:String = data.tool;
                var status:String = data.status;
                var symbol:Symbol = data.symbol;

                if (tool)
                {
                    // make sure there is no custom cursor
                    map.cursorManager.removeAllCursors();
                    map.removeEventListener(MouseEvent.ROLL_OVER, map_rollOverHandler);
                    map.removeEventListener(MouseEvent.ROLL_OUT, map_rollOutHandler);

                    drawEndFunction = data.handler;
                    navTool.deactivate();
                    drawTool.activate(tool);
                    // reset symbology
                    drawTool.markerSymbol = new SimpleMarkerSymbol;
                    drawTool.lineSymbol = new SimpleLineSymbol;
                    drawTool.fillSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, 0, 0.5, new SimpleLineSymbol);
                    if (symbol)
                    {
                        if (symbol is TextSymbol || symbol is SimpleMarkerSymbol)
                        {
                            drawTool.markerSymbol = symbol;
                        }
                        else if (symbol is SimpleLineSymbol)
                        {
                            drawTool.lineSymbol = symbol;
                        }
                        else if (symbol is SimpleFillSymbol)
                        {
                            drawTool.fillSymbol = symbol;
                        }
                    }

                    //map.zoomSliderVisible = true;
                    ViewerContainer.setStatus(status);
                }
                else
                {
                    drawTool.deactivate();
                    restoreNavigation();
                }
            }

            private function onDrawEnd(event:DrawEvent):void
            {
                restoreNavigation();
                drawEndFunction(event);
            }

            private function restoreNavigation():void
            {
                if (navigationTool == NavigationTool.ZOOM_IN || navigationTool == NavigationTool.ZOOM_OUT || navigationTool == NavigationTool.PAN)
                {
                    if (!(navigationTool == NavigationTool.PAN))
                    {
                        map.cursorManager.setCursor(_crossCursor, CursorManagerPriority.MEDIUM, -8, -8);
                    }
                    changeNavigation(navigationTool, navigationStatus);
                }
            }

            private function changeLayerVisible(event:AppEvent):void
            {
                var lyrData:Object = event.data;

                lyrData.layer.visible = lyrData.visible;

                //ViewerContainer.publish(AppEvent.LAYER_VISIBLE_CHANGED, event.data);
            }

            //basemap menu clicked
            private function basemapMenuClicked(event:AppEvent):void
            {
                var id:String = event.data as String;
                var configBasemaps:Array = configData.basemaps;

                if (id)
                {
                    var selectedLabel:String;
                    for (var i:uint = 0; i < configBasemaps.length; i++)
                    {
                        if (configBasemaps[i].id == id)
                        {
                            selectedLabel = configBasemaps[i].label;
                            break;
                        }
                    }
                    if (selectedLabel)
                    {
                        // turn on the selected basemap layers (more than one layer can have the same label) 
                        var layers:ArrayCollection = map.layers as ArrayCollection;
                        for (i = 0; i < configBasemaps.length; i++)
                        {
                            var basemapLabel:String = configBasemaps[i].label;
                            for each (var layer:Layer in layers)
                            {
                                if (layer.id == basemapLabel)
                                {
                                    if (layer.id == selectedLabel)
                                    {
                                        layer.visible = true;
                                    }
                                    else
                                    {
                                        layer.visible = false;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            private function widgetShowInfo(event:AppEvent):void
            {
                infoPopup.infoData = event.data;
            }

            private function resizeMap(event:AppEvent):void
            {
                var size:Object = event.data;

                mapLeft = size.left;
                mapRight = size.right;
                mapTop = size.top;
                mapBottom = size.bottom;

                this._mapManagerState = "resized";

                dispatchEvent(new Event(_mapManagerState));
                invalidateSkinState();
            }

            private function nlsString(nlsToken:String):String
            {
                return resourceManager.getString("ViewerStrings", nlsToken);
            }
        ]]>
    </fx:Script>
</s:SkinnableContainer>
